// proxy.ts
import {getToken} from 'next-auth/jwt'
import {NextRequest, NextResponse} from 'next/server'
import type {JWT} from 'next-auth/jwt'
import { HREF } from '@cm/lib/methods/urls'

/**
 * セッション検証関数の型定義
 */
type SessionValidator = (session: JWT | null) => boolean

/**
 * リダイレクトURL生成関数の型定義
 */
type RedirectUrlBuilder = (origin: string, rootPath: string) => string

/**
 * パス検証設定
 */
const pathValidation = {
  isValid: (session: JWT | null): boolean => {
    return Boolean(session?.email)
  },
  redirect: (origin: string, rootPath: string): string => {
    return `${origin}/not-found?rootPath=${rootPath}`
  },
} satisfies {
  isValid: SessionValidator
  redirect: RedirectUrlBuilder
}

/**
 * パス設定の型定義
 */
type PathConfig = {
  matcher: string
  isValid: SessionValidator
  redirect: RedirectUrlBuilder
}

type RootPathConfig = {
  rootPath: string
  paths: PathConfig[]
}

/**
 * 認証が必要なパスのマッチャーを生成（除外パス以外にマッチさせる）
 * @param rootPath - ルートパス名（例: 'ucar'）
 * @param pathArray - 認証不要なパスの配列（例: ['/sateiIdConverter']）
 * @returns 正規表現パターン文字列
 */
const getFreePathsMatcher = (rootPath: string, pathArray: string[]): string => {
  const defaultFreePaths = [`/.*api`, `/seeder`]
  const allFreePaths = [...defaultFreePaths, ...pathArray]

  // 1. 特殊文字（/）をエスケープし、完全一致またはディレクトリ区切りとして機能させる
  // 2. (?!(?:path1|path2)(?:/|$)) で、除外パス（およびその配下）にマッチしないことを確認
  // 3. (?:/.*)? で、ルート直下およびサブディレクトリすべてを網羅
  const excludedPathsPattern = allFreePaths.join('|')
  const result = `^/${rootPath}(?!(?:${excludedPathsPattern})(?:/|$))(?:/.*)?$`

  return result
}
export const rootPaths: RootPathConfig[] = [
  {
    rootPath: 'newCar',
    paths: [{matcher: getFreePathsMatcher(`newCar`, []), ...pathValidation}],
  },
  {
    rootPath: 'QRBP',
    paths: [{matcher: getFreePathsMatcher(`QRBP`, ['', `/engineer`, `/process/history`]), ...pathValidation,},
    ],
  },
  {
    rootPath: 'shinren',
    paths: [
      {
        matcher: getFreePathsMatcher(`shinren`, []),
        ...pathValidation,
      },
    ],
  },
  {
    rootPath: 'ucar',
    paths: [
      {
        // /ucar や /ucar/ucar は通さないようホワイトリストで明示していない
        matcher: getFreePathsMatcher('ucar', [
          '/sateiIdConverter',
          '/admin/InstantQr',
          // ホワイトリストとしてトップ（/）やucar直下（/ucar）は通さない
          // '/': コメントアウト・未追加
          // '/ucar': コメントアウト・未追加
        ]),
        ...pathValidation,
      },
    ],
  },
]
/**
 * Next.js proxy関数
 * 認証が必要なパスへのアクセスを検証し、未認証の場合はリダイレクト
 */
export async function proxy(req: NextRequest): Promise<NextResponse> {


  try {
    // NextAuthからセッショントークンを取得
    const session: JWT | null = await getToken({req})



    const {pathname, origin,searchParams} = req.nextUrl
    const query= {}
    searchParams.forEach((value, key) => {
      query[key] = value
    })


    // 対象となるルートパスを検索
    const targetPathConfig = rootPaths.find(config => {
      const rootPathRegex = new RegExp(`^/${config.rootPath}`)
      return rootPathRegex.test(pathname)
    })

    if (!targetPathConfig) {
      // 対象パスでない場合はそのまま通過
      return NextResponse.next()
    }

    // パス設定に一致するマッチャーを検索
    if (targetPathConfig.paths.length > 0) {
      const matchedPathConfig = targetPathConfig.paths.find(pathConfig => {
        try {
          const matcherRegex = new RegExp(pathConfig.matcher)
          return matcherRegex.test(pathname)
        } catch (error) {
          // 正規表現エラーの場合はログを出力してスキップ
          console.error(`Invalid regex pattern: ${pathConfig.matcher}`, error)
          return false
        }
      })

      const isValid = matchedPathConfig?.isValid(session)
      // マッチしたパスで認証が必要な場合、セッションを検証
      if (matchedPathConfig && !isValid) {
        const callBackUrl =  encodeURIComponent(HREF(`${pathname}`, query, query))
        const redirectUrl = matchedPathConfig.redirect(origin, callBackUrl)

        return NextResponse.redirect(new URL(redirectUrl, req.url))
      }
    }

    return NextResponse.next()
  } catch (error) {
    // エラーが発生した場合はログを出力してそのまま通過
    // （本番環境では適切なエラーハンドリングを検討）
    console.error('Proxy error:', error)
    return NextResponse.next()
  }
}

/**
 * Proxy設定
 * マッチャーで対象となるパスを指定
 * Next.jsのproxyでは、config.matcherは静的な値である必要があります
 */
// const config = {
//   matcher: [
//     '/ucar(.*)',
//     '/newCar(.*)',
//     '/QRBP(.*)',
//     '/shinren(.*)',/g
//     '/((?!api|_next/static|favicon.ico|manifest|next-js-icon).*)',
//   ],
// } as const

export default proxy

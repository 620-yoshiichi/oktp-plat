
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * WARNING: This is an internal file that is subject to change!
 *
 * ðŸ›‘ Under no circumstances should you import this file directly! ðŸ›‘
 *
 * All exports from this file are wrapped under a `Prisma` namespace object in the client.ts file.
 * While this enables partial backward compatibility, it is not part of the stable public API.
 *
 * If you are looking for your Models, Enums, and Input Types, please import them from the respective
 * model files in the `model` directory!
 */

import * as runtime from "@prisma/client/runtime/client"
import type * as Prisma from "../models"
import { type PrismaClient } from "./class"

export type * from '../models'

export type DMMF = typeof runtime.DMMF

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

/**
 * Prisma Errors
 */

export const PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
export type PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError

export const PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
export type PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError

export const PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
export type PrismaClientRustPanicError = runtime.PrismaClientRustPanicError

export const PrismaClientInitializationError = runtime.PrismaClientInitializationError
export type PrismaClientInitializationError = runtime.PrismaClientInitializationError

export const PrismaClientValidationError = runtime.PrismaClientValidationError
export type PrismaClientValidationError = runtime.PrismaClientValidationError

/**
 * Re-export of sql-template-tag
 */
export const sql = runtime.sqltag
export const empty = runtime.empty
export const join = runtime.join
export const raw = runtime.raw
export const Sql = runtime.Sql
export type Sql = runtime.Sql



/**
 * Decimal.js
 */
export const Decimal = runtime.Decimal
export type Decimal = runtime.Decimal

export type DecimalJsLike = runtime.DecimalJsLike

/**
* Extensions
*/
export type Extension = runtime.Types.Extensions.UserArgs
export const getExtensionContext = runtime.Extensions.getExtensionContext
export type Args<T, F extends runtime.Operation> = runtime.Types.Public.Args<T, F>
export type Payload<T, F extends runtime.Operation = never> = runtime.Types.Public.Payload<T, F>
export type Result<T, A, F extends runtime.Operation> = runtime.Types.Public.Result<T, A, F>
export type Exact<A, W> = runtime.Types.Public.Exact<A, W>

export type PrismaVersion = {
  client: string
  engine: string
}

/**
 * Prisma Client JS version: 7.3.0
 * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
 */
export const prismaVersion: PrismaVersion = {
  client: "7.3.0",
  engine: "9d6ad21cbbceab97458517b147a6a09ff43aa735"
}

/**
 * Utility Types
 */

export type Bytes = runtime.Bytes
export type JsonObject = runtime.JsonObject
export type JsonArray = runtime.JsonArray
export type JsonValue = runtime.JsonValue
export type InputJsonObject = runtime.InputJsonObject
export type InputJsonArray = runtime.InputJsonArray
export type InputJsonValue = runtime.InputJsonValue


export const NullTypes = {
  DbNull: runtime.NullTypes.DbNull as (new (secret: never) => typeof runtime.DbNull),
  JsonNull: runtime.NullTypes.JsonNull as (new (secret: never) => typeof runtime.JsonNull),
  AnyNull: runtime.NullTypes.AnyNull as (new (secret: never) => typeof runtime.AnyNull),
}
/**
 * Helper for filtering JSON entries that have `null` on the database (empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const DbNull = runtime.DbNull

/**
 * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const JsonNull = runtime.JsonNull

/**
 * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
 *
 * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
 */
export const AnyNull = runtime.AnyNull


type SelectAndInclude = {
  select: any
  include: any
}

type SelectAndOmit = {
  select: any
  omit: any
}

/**
 * From T, pick a set of properties whose keys are in the union K
 */
type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
};

export type Enumerable<T> = T | Array<T>;

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};

/**
 * SelectSubset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
 * Additionally, it validates, if both select and include are present. If the case, it errors.
 */
export type SelectSubset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {})

/**
 * Subset + Intersection
 * @desc From `T` pick properties that exist in `U` and intersect `K`
 */
export type SubsetIntersection<T, U, K> = {
  [key in keyof T]: key extends keyof U ? T[key] : never
} &
  K

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

/**
 * XOR is needed to have a real mutually exclusive union type
 * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
 */
export type XOR<T, U> =
  T extends object ?
  U extends object ?
    (Without<T, U> & U) | (Without<U, T> & T)
  : U : T


/**
 * Is T a Record?
 */
type IsObject<T extends any> = T extends Array<any>
? False
: T extends Date
? False
: T extends Uint8Array
? False
: T extends BigInt
? False
: T extends object
? True
: False


/**
 * If it's T[], return T
 */
export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

/**
 * From ts-toolbelt
 */

type __Either<O extends object, K extends Key> = Omit<O, K> &
  {
    // Merge all but K
    [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
  }[K]

type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

type _Either<
  O extends object,
  K extends Key,
  strict extends Boolean
> = {
  1: EitherStrict<O, K>
  0: EitherLoose<O, K>
}[strict]

export type Either<
  O extends object,
  K extends Key,
  strict extends Boolean = 1
> = O extends unknown ? _Either<O, K, strict> : never

export type Union = any

export type PatchUndefined<O extends object, O1 extends object> = {
  [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
} & {}

/** Helper Types for "Merge" **/
export type IntersectOf<U extends Union> = (
  U extends unknown ? (k: U) => void : never
) extends (k: infer I) => void
  ? I
  : never

export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
} & {};

type _Merge<U extends object> = IntersectOf<Overwrite<U, {
    [K in keyof U]-?: At<U, K>;
}>>;

type Key = string | number | symbol;
type AtStrict<O extends object, K extends Key> = O[K & keyof O];
type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
}[strict];

export type ComputeRaw<A extends any> = A extends Function ? A : {
  [K in keyof A]: A[K];
} & {};

export type OptionalFlat<O> = {
  [K in keyof O]?: O[K];
} & {};

type _Record<K extends keyof any, T> = {
  [P in K]: T;
};

// cause typescript not to expand types and preserve names
type NoExpand<T> = T extends unknown ? T : never;

// this type assumes the passed object is entirely optional
export type AtLeast<O extends object, K extends string> = NoExpand<
  O extends unknown
  ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
    | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
  : never>;

type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
/** End Helper Types for "Merge" **/

export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

export type Boolean = True | False

export type True = 1

export type False = 0

export type Not<B extends Boolean> = {
  0: 1
  1: 0
}[B]

export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
  ? 0 // anything `never` is false
  : A1 extends A2
  ? 1
  : 0

export type Has<U extends Union, U1 extends Union> = Not<
  Extends<Exclude<U1, U>, U1>
>

export type Or<B1 extends Boolean, B2 extends Boolean> = {
  0: {
    0: 0
    1: 1
  }
  1: {
    0: 1
    1: 1
  }
}[B1][B2]

export type Keys<U extends Union> = U extends unknown ? keyof U : never

export type GetScalarType<T, O> = O extends object ? {
  [P in keyof T]: P extends keyof O
    ? O[P]
    : never
} : never

type FieldPaths<
  T,
  U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
> = IsObject<T> extends True ? U : T

export type GetHavingFields<T> = {
  [K in keyof T]: Or<
    Or<Extends<'OR', K>, Extends<'AND', K>>,
    Extends<'NOT', K>
  > extends True
    ? // infer is only needed to not hit TS limit
      // based on the brilliant idea of Pierre-Antoine Mills
      // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
      T[K] extends infer TK
      ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
      : never
    : {} extends FieldPaths<T[K]>
    ? never
    : K
}[keyof T]

/**
 * Convert tuple to union
 */
type _TupleToUnion<T> = T extends (infer E)[] ? E : never
type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
export type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

/**
 * Like `Pick`, but additionally can also accept an array of keys
 */
export type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

/**
 * Exclude all keys with underscores
 */
export type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


export const ModelName = {
  Car: 'Car',
  UserProcessConfirmation: 'UserProcessConfirmation',
  Notes: 'Notes',
  DamageNameMaster: 'DamageNameMaster',
  NoteNameMaster: 'NoteNameMaster',
  BpSummary: 'BpSummary',
  ProcessNameMaster: 'ProcessNameMaster',
  Process: 'Process',
  ReleaseNotes: 'ReleaseNotes',
  CrUser: 'CrUser',
  JuchuShitadoriDb: 'JuchuShitadoriDb',
  OldCars_Base: 'OldCars_Base',
  Number98: 'Number98',
  ZAIKO_Base: 'ZAIKO_Base',
  UpassFamilyTree: 'UpassFamilyTree',
  UPASS: 'UPASS',
  QR_Prosess: 'QR_Prosess',
  DeliverSchedule: 'DeliverSchedule',
  Area: 'Area',
  LoadingVehicle: 'LoadingVehicle',
  Slot: 'Slot',
  NewCar: 'NewCar',
  OrderSwitchingHisotory: 'OrderSwitchingHisotory',
  DesiredTorokuDate: 'DesiredTorokuDate',
  NewCarLeadTime: 'NewCarLeadTime',
  CrInspectionHistory: 'CrInspectionHistory',
  SeisanYoteiHistory: 'SeisanYoteiHistory',
  UserProgressAggregationTable: 'UserProgressAggregationTable',
  ProgressAggregationTable: 'ProgressAggregationTable',
  ProgressAggregationTableRecord: 'ProgressAggregationTableRecord',
  FuriateStatusOnApprovement: 'FuriateStatusOnApprovement',
  CarTransferHistory: 'CarTransferHistory',
  TenpoTsuikoShinseiHeader: 'TenpoTsuikoShinseiHeader',
  TenpoTsuikoShinseiDetail: 'TenpoTsuikoShinseiDetail',
  TenpoTsuikoData: 'TenpoTsuikoData',
  Store: 'Store',
  User: 'User',
  GoogleAccessToken: 'GoogleAccessToken',
  RoleMaster: 'RoleMaster',
  UserRole: 'UserRole',
  Calendar: 'Calendar',
  ChainMethodLock: 'ChainMethodLock',
  CronExecutionLog: 'CronExecutionLog',
  RentaStore: 'RentaStore',
  RentaDeal: 'RentaDeal',
  RentaDailyReport: 'RentaDailyReport',
  RentaCustomer: 'RentaCustomer',
  RentaReference: 'RentaReference',
  RefFrom: 'RefFrom',
  RefTo: 'RefTo',
  Purpose: 'Purpose',
  PurposeMaster: 'PurposeMaster',
  Outcome: 'Outcome',
  OutcomeMaster: 'OutcomeMaster',
  AlternateInfo: 'AlternateInfo',
  InsuranceInfo: 'InsuranceInfo',
  ExtraInfo: 'ExtraInfo',
  Ucar: 'Ucar',
  Number98IssueHistory: 'Number98IssueHistory',
  AppliedUcarGarageSlot: 'AppliedUcarGarageSlot',
  UcarGarageSlotMaster: 'UcarGarageSlotMaster',
  UcarGarageLocationMaster: 'UcarGarageLocationMaster',
  BankMaster: 'BankMaster',
  BankBranchMaster: 'BankBranchMaster',
  UcarProcess: 'UcarProcess',
  UcarPaperWorkNotes: 'UcarPaperWorkNotes',
  UcarRequest: 'UcarRequest'
} as const

export type ModelName = (typeof ModelName)[keyof typeof ModelName]



export interface TypeMapCb<GlobalOmitOptions = {}> extends runtime.Types.Utils.Fn<{extArgs: runtime.Types.Extensions.InternalArgs }, runtime.Types.Utils.Record<string, any>> {
  returns: TypeMap<this['params']['extArgs'], GlobalOmitOptions>
}

export type TypeMap<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
  globalOmitOptions: {
    omit: GlobalOmitOptions
  }
  meta: {
    modelProps: "car" | "userProcessConfirmation" | "notes" | "damageNameMaster" | "noteNameMaster" | "bpSummary" | "processNameMaster" | "process" | "releaseNotes" | "crUser" | "juchuShitadoriDb" | "oldCars_Base" | "number98" | "zAIKO_Base" | "upassFamilyTree" | "uPASS" | "qR_Prosess" | "deliverSchedule" | "area" | "loadingVehicle" | "slot" | "newCar" | "orderSwitchingHisotory" | "desiredTorokuDate" | "newCarLeadTime" | "crInspectionHistory" | "seisanYoteiHistory" | "userProgressAggregationTable" | "progressAggregationTable" | "progressAggregationTableRecord" | "furiateStatusOnApprovement" | "carTransferHistory" | "tenpoTsuikoShinseiHeader" | "tenpoTsuikoShinseiDetail" | "tenpoTsuikoData" | "store" | "user" | "googleAccessToken" | "roleMaster" | "userRole" | "calendar" | "chainMethodLock" | "cronExecutionLog" | "rentaStore" | "rentaDeal" | "rentaDailyReport" | "rentaCustomer" | "rentaReference" | "refFrom" | "refTo" | "purpose" | "purposeMaster" | "outcome" | "outcomeMaster" | "alternateInfo" | "insuranceInfo" | "extraInfo" | "ucar" | "number98IssueHistory" | "appliedUcarGarageSlot" | "ucarGarageSlotMaster" | "ucarGarageLocationMaster" | "bankMaster" | "bankBranchMaster" | "ucarProcess" | "ucarPaperWorkNotes" | "ucarRequest"
    txIsolationLevel: TransactionIsolationLevel
  }
  model: {
    Car: {
      payload: Prisma.$CarPayload<ExtArgs>
      fields: Prisma.CarFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CarFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CarFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarPayload>
        }
        findFirst: {
          args: Prisma.CarFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CarFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarPayload>
        }
        findMany: {
          args: Prisma.CarFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarPayload>[]
        }
        create: {
          args: Prisma.CarCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarPayload>
        }
        createMany: {
          args: Prisma.CarCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CarCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarPayload>[]
        }
        delete: {
          args: Prisma.CarDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarPayload>
        }
        update: {
          args: Prisma.CarUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarPayload>
        }
        deleteMany: {
          args: Prisma.CarDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CarUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CarUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarPayload>[]
        }
        upsert: {
          args: Prisma.CarUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarPayload>
        }
        aggregate: {
          args: Prisma.CarAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCar>
        }
        groupBy: {
          args: Prisma.CarGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CarGroupByOutputType>[]
        }
        count: {
          args: Prisma.CarCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CarCountAggregateOutputType> | number
        }
      }
    }
    UserProcessConfirmation: {
      payload: Prisma.$UserProcessConfirmationPayload<ExtArgs>
      fields: Prisma.UserProcessConfirmationFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserProcessConfirmationFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProcessConfirmationPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserProcessConfirmationFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProcessConfirmationPayload>
        }
        findFirst: {
          args: Prisma.UserProcessConfirmationFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProcessConfirmationPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserProcessConfirmationFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProcessConfirmationPayload>
        }
        findMany: {
          args: Prisma.UserProcessConfirmationFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProcessConfirmationPayload>[]
        }
        create: {
          args: Prisma.UserProcessConfirmationCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProcessConfirmationPayload>
        }
        createMany: {
          args: Prisma.UserProcessConfirmationCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserProcessConfirmationCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProcessConfirmationPayload>[]
        }
        delete: {
          args: Prisma.UserProcessConfirmationDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProcessConfirmationPayload>
        }
        update: {
          args: Prisma.UserProcessConfirmationUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProcessConfirmationPayload>
        }
        deleteMany: {
          args: Prisma.UserProcessConfirmationDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserProcessConfirmationUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserProcessConfirmationUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProcessConfirmationPayload>[]
        }
        upsert: {
          args: Prisma.UserProcessConfirmationUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProcessConfirmationPayload>
        }
        aggregate: {
          args: Prisma.UserProcessConfirmationAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserProcessConfirmation>
        }
        groupBy: {
          args: Prisma.UserProcessConfirmationGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserProcessConfirmationGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserProcessConfirmationCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserProcessConfirmationCountAggregateOutputType> | number
        }
      }
    }
    Notes: {
      payload: Prisma.$NotesPayload<ExtArgs>
      fields: Prisma.NotesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NotesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NotesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotesPayload>
        }
        findFirst: {
          args: Prisma.NotesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NotesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotesPayload>
        }
        findMany: {
          args: Prisma.NotesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotesPayload>[]
        }
        create: {
          args: Prisma.NotesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotesPayload>
        }
        createMany: {
          args: Prisma.NotesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NotesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotesPayload>[]
        }
        delete: {
          args: Prisma.NotesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotesPayload>
        }
        update: {
          args: Prisma.NotesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotesPayload>
        }
        deleteMany: {
          args: Prisma.NotesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NotesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NotesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotesPayload>[]
        }
        upsert: {
          args: Prisma.NotesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NotesPayload>
        }
        aggregate: {
          args: Prisma.NotesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNotes>
        }
        groupBy: {
          args: Prisma.NotesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotesGroupByOutputType>[]
        }
        count: {
          args: Prisma.NotesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NotesCountAggregateOutputType> | number
        }
      }
    }
    DamageNameMaster: {
      payload: Prisma.$DamageNameMasterPayload<ExtArgs>
      fields: Prisma.DamageNameMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DamageNameMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DamageNameMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DamageNameMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DamageNameMasterPayload>
        }
        findFirst: {
          args: Prisma.DamageNameMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DamageNameMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DamageNameMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DamageNameMasterPayload>
        }
        findMany: {
          args: Prisma.DamageNameMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DamageNameMasterPayload>[]
        }
        create: {
          args: Prisma.DamageNameMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DamageNameMasterPayload>
        }
        createMany: {
          args: Prisma.DamageNameMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DamageNameMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DamageNameMasterPayload>[]
        }
        delete: {
          args: Prisma.DamageNameMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DamageNameMasterPayload>
        }
        update: {
          args: Prisma.DamageNameMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DamageNameMasterPayload>
        }
        deleteMany: {
          args: Prisma.DamageNameMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DamageNameMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DamageNameMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DamageNameMasterPayload>[]
        }
        upsert: {
          args: Prisma.DamageNameMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DamageNameMasterPayload>
        }
        aggregate: {
          args: Prisma.DamageNameMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDamageNameMaster>
        }
        groupBy: {
          args: Prisma.DamageNameMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DamageNameMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.DamageNameMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DamageNameMasterCountAggregateOutputType> | number
        }
      }
    }
    NoteNameMaster: {
      payload: Prisma.$NoteNameMasterPayload<ExtArgs>
      fields: Prisma.NoteNameMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NoteNameMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteNameMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NoteNameMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteNameMasterPayload>
        }
        findFirst: {
          args: Prisma.NoteNameMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteNameMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NoteNameMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteNameMasterPayload>
        }
        findMany: {
          args: Prisma.NoteNameMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteNameMasterPayload>[]
        }
        create: {
          args: Prisma.NoteNameMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteNameMasterPayload>
        }
        createMany: {
          args: Prisma.NoteNameMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NoteNameMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteNameMasterPayload>[]
        }
        delete: {
          args: Prisma.NoteNameMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteNameMasterPayload>
        }
        update: {
          args: Prisma.NoteNameMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteNameMasterPayload>
        }
        deleteMany: {
          args: Prisma.NoteNameMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NoteNameMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NoteNameMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteNameMasterPayload>[]
        }
        upsert: {
          args: Prisma.NoteNameMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NoteNameMasterPayload>
        }
        aggregate: {
          args: Prisma.NoteNameMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNoteNameMaster>
        }
        groupBy: {
          args: Prisma.NoteNameMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NoteNameMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.NoteNameMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NoteNameMasterCountAggregateOutputType> | number
        }
      }
    }
    BpSummary: {
      payload: Prisma.$BpSummaryPayload<ExtArgs>
      fields: Prisma.BpSummaryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BpSummaryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BpSummaryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BpSummaryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BpSummaryPayload>
        }
        findFirst: {
          args: Prisma.BpSummaryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BpSummaryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BpSummaryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BpSummaryPayload>
        }
        findMany: {
          args: Prisma.BpSummaryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BpSummaryPayload>[]
        }
        create: {
          args: Prisma.BpSummaryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BpSummaryPayload>
        }
        createMany: {
          args: Prisma.BpSummaryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BpSummaryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BpSummaryPayload>[]
        }
        delete: {
          args: Prisma.BpSummaryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BpSummaryPayload>
        }
        update: {
          args: Prisma.BpSummaryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BpSummaryPayload>
        }
        deleteMany: {
          args: Prisma.BpSummaryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BpSummaryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BpSummaryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BpSummaryPayload>[]
        }
        upsert: {
          args: Prisma.BpSummaryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BpSummaryPayload>
        }
        aggregate: {
          args: Prisma.BpSummaryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBpSummary>
        }
        groupBy: {
          args: Prisma.BpSummaryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BpSummaryGroupByOutputType>[]
        }
        count: {
          args: Prisma.BpSummaryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BpSummaryCountAggregateOutputType> | number
        }
      }
    }
    ProcessNameMaster: {
      payload: Prisma.$ProcessNameMasterPayload<ExtArgs>
      fields: Prisma.ProcessNameMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProcessNameMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessNameMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProcessNameMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessNameMasterPayload>
        }
        findFirst: {
          args: Prisma.ProcessNameMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessNameMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProcessNameMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessNameMasterPayload>
        }
        findMany: {
          args: Prisma.ProcessNameMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessNameMasterPayload>[]
        }
        create: {
          args: Prisma.ProcessNameMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessNameMasterPayload>
        }
        createMany: {
          args: Prisma.ProcessNameMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProcessNameMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessNameMasterPayload>[]
        }
        delete: {
          args: Prisma.ProcessNameMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessNameMasterPayload>
        }
        update: {
          args: Prisma.ProcessNameMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessNameMasterPayload>
        }
        deleteMany: {
          args: Prisma.ProcessNameMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProcessNameMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProcessNameMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessNameMasterPayload>[]
        }
        upsert: {
          args: Prisma.ProcessNameMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessNameMasterPayload>
        }
        aggregate: {
          args: Prisma.ProcessNameMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProcessNameMaster>
        }
        groupBy: {
          args: Prisma.ProcessNameMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProcessNameMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProcessNameMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProcessNameMasterCountAggregateOutputType> | number
        }
      }
    }
    Process: {
      payload: Prisma.$ProcessPayload<ExtArgs>
      fields: Prisma.ProcessFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProcessFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProcessFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessPayload>
        }
        findFirst: {
          args: Prisma.ProcessFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProcessFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessPayload>
        }
        findMany: {
          args: Prisma.ProcessFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessPayload>[]
        }
        create: {
          args: Prisma.ProcessCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessPayload>
        }
        createMany: {
          args: Prisma.ProcessCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProcessCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessPayload>[]
        }
        delete: {
          args: Prisma.ProcessDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessPayload>
        }
        update: {
          args: Prisma.ProcessUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessPayload>
        }
        deleteMany: {
          args: Prisma.ProcessDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProcessUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProcessUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessPayload>[]
        }
        upsert: {
          args: Prisma.ProcessUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProcessPayload>
        }
        aggregate: {
          args: Prisma.ProcessAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProcess>
        }
        groupBy: {
          args: Prisma.ProcessGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProcessGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProcessCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProcessCountAggregateOutputType> | number
        }
      }
    }
    ReleaseNotes: {
      payload: Prisma.$ReleaseNotesPayload<ExtArgs>
      fields: Prisma.ReleaseNotesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ReleaseNotesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleaseNotesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ReleaseNotesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleaseNotesPayload>
        }
        findFirst: {
          args: Prisma.ReleaseNotesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleaseNotesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ReleaseNotesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleaseNotesPayload>
        }
        findMany: {
          args: Prisma.ReleaseNotesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleaseNotesPayload>[]
        }
        create: {
          args: Prisma.ReleaseNotesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleaseNotesPayload>
        }
        createMany: {
          args: Prisma.ReleaseNotesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ReleaseNotesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleaseNotesPayload>[]
        }
        delete: {
          args: Prisma.ReleaseNotesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleaseNotesPayload>
        }
        update: {
          args: Prisma.ReleaseNotesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleaseNotesPayload>
        }
        deleteMany: {
          args: Prisma.ReleaseNotesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ReleaseNotesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ReleaseNotesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleaseNotesPayload>[]
        }
        upsert: {
          args: Prisma.ReleaseNotesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ReleaseNotesPayload>
        }
        aggregate: {
          args: Prisma.ReleaseNotesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateReleaseNotes>
        }
        groupBy: {
          args: Prisma.ReleaseNotesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReleaseNotesGroupByOutputType>[]
        }
        count: {
          args: Prisma.ReleaseNotesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ReleaseNotesCountAggregateOutputType> | number
        }
      }
    }
    CrUser: {
      payload: Prisma.$CrUserPayload<ExtArgs>
      fields: Prisma.CrUserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CrUserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrUserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CrUserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrUserPayload>
        }
        findFirst: {
          args: Prisma.CrUserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrUserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CrUserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrUserPayload>
        }
        findMany: {
          args: Prisma.CrUserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrUserPayload>[]
        }
        create: {
          args: Prisma.CrUserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrUserPayload>
        }
        createMany: {
          args: Prisma.CrUserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CrUserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrUserPayload>[]
        }
        delete: {
          args: Prisma.CrUserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrUserPayload>
        }
        update: {
          args: Prisma.CrUserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrUserPayload>
        }
        deleteMany: {
          args: Prisma.CrUserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CrUserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CrUserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrUserPayload>[]
        }
        upsert: {
          args: Prisma.CrUserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrUserPayload>
        }
        aggregate: {
          args: Prisma.CrUserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCrUser>
        }
        groupBy: {
          args: Prisma.CrUserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CrUserGroupByOutputType>[]
        }
        count: {
          args: Prisma.CrUserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CrUserCountAggregateOutputType> | number
        }
      }
    }
    JuchuShitadoriDb: {
      payload: Prisma.$JuchuShitadoriDbPayload<ExtArgs>
      fields: Prisma.JuchuShitadoriDbFieldRefs
      operations: {
        findUnique: {
          args: Prisma.JuchuShitadoriDbFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JuchuShitadoriDbPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.JuchuShitadoriDbFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JuchuShitadoriDbPayload>
        }
        findFirst: {
          args: Prisma.JuchuShitadoriDbFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JuchuShitadoriDbPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.JuchuShitadoriDbFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JuchuShitadoriDbPayload>
        }
        findMany: {
          args: Prisma.JuchuShitadoriDbFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JuchuShitadoriDbPayload>[]
        }
        create: {
          args: Prisma.JuchuShitadoriDbCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JuchuShitadoriDbPayload>
        }
        createMany: {
          args: Prisma.JuchuShitadoriDbCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.JuchuShitadoriDbCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JuchuShitadoriDbPayload>[]
        }
        delete: {
          args: Prisma.JuchuShitadoriDbDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JuchuShitadoriDbPayload>
        }
        update: {
          args: Prisma.JuchuShitadoriDbUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JuchuShitadoriDbPayload>
        }
        deleteMany: {
          args: Prisma.JuchuShitadoriDbDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.JuchuShitadoriDbUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.JuchuShitadoriDbUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JuchuShitadoriDbPayload>[]
        }
        upsert: {
          args: Prisma.JuchuShitadoriDbUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$JuchuShitadoriDbPayload>
        }
        aggregate: {
          args: Prisma.JuchuShitadoriDbAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateJuchuShitadoriDb>
        }
        groupBy: {
          args: Prisma.JuchuShitadoriDbGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.JuchuShitadoriDbGroupByOutputType>[]
        }
        count: {
          args: Prisma.JuchuShitadoriDbCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.JuchuShitadoriDbCountAggregateOutputType> | number
        }
      }
    }
    OldCars_Base: {
      payload: Prisma.$OldCars_BasePayload<ExtArgs>
      fields: Prisma.OldCars_BaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OldCars_BaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OldCars_BasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OldCars_BaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OldCars_BasePayload>
        }
        findFirst: {
          args: Prisma.OldCars_BaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OldCars_BasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OldCars_BaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OldCars_BasePayload>
        }
        findMany: {
          args: Prisma.OldCars_BaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OldCars_BasePayload>[]
        }
        create: {
          args: Prisma.OldCars_BaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OldCars_BasePayload>
        }
        createMany: {
          args: Prisma.OldCars_BaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OldCars_BaseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OldCars_BasePayload>[]
        }
        delete: {
          args: Prisma.OldCars_BaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OldCars_BasePayload>
        }
        update: {
          args: Prisma.OldCars_BaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OldCars_BasePayload>
        }
        deleteMany: {
          args: Prisma.OldCars_BaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OldCars_BaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OldCars_BaseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OldCars_BasePayload>[]
        }
        upsert: {
          args: Prisma.OldCars_BaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OldCars_BasePayload>
        }
        aggregate: {
          args: Prisma.OldCars_BaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOldCars_Base>
        }
        groupBy: {
          args: Prisma.OldCars_BaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OldCars_BaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.OldCars_BaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OldCars_BaseCountAggregateOutputType> | number
        }
      }
    }
    Number98: {
      payload: Prisma.$Number98Payload<ExtArgs>
      fields: Prisma.Number98FieldRefs
      operations: {
        findUnique: {
          args: Prisma.Number98FindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98Payload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Number98FindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98Payload>
        }
        findFirst: {
          args: Prisma.Number98FindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98Payload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Number98FindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98Payload>
        }
        findMany: {
          args: Prisma.Number98FindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98Payload>[]
        }
        create: {
          args: Prisma.Number98CreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98Payload>
        }
        createMany: {
          args: Prisma.Number98CreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.Number98CreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98Payload>[]
        }
        delete: {
          args: Prisma.Number98DeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98Payload>
        }
        update: {
          args: Prisma.Number98UpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98Payload>
        }
        deleteMany: {
          args: Prisma.Number98DeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Number98UpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.Number98UpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98Payload>[]
        }
        upsert: {
          args: Prisma.Number98UpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98Payload>
        }
        aggregate: {
          args: Prisma.Number98AggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNumber98>
        }
        groupBy: {
          args: Prisma.Number98GroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Number98GroupByOutputType>[]
        }
        count: {
          args: Prisma.Number98CountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Number98CountAggregateOutputType> | number
        }
      }
    }
    ZAIKO_Base: {
      payload: Prisma.$ZAIKO_BasePayload<ExtArgs>
      fields: Prisma.ZAIKO_BaseFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ZAIKO_BaseFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZAIKO_BasePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ZAIKO_BaseFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZAIKO_BasePayload>
        }
        findFirst: {
          args: Prisma.ZAIKO_BaseFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZAIKO_BasePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ZAIKO_BaseFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZAIKO_BasePayload>
        }
        findMany: {
          args: Prisma.ZAIKO_BaseFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZAIKO_BasePayload>[]
        }
        create: {
          args: Prisma.ZAIKO_BaseCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZAIKO_BasePayload>
        }
        createMany: {
          args: Prisma.ZAIKO_BaseCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ZAIKO_BaseCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZAIKO_BasePayload>[]
        }
        delete: {
          args: Prisma.ZAIKO_BaseDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZAIKO_BasePayload>
        }
        update: {
          args: Prisma.ZAIKO_BaseUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZAIKO_BasePayload>
        }
        deleteMany: {
          args: Prisma.ZAIKO_BaseDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ZAIKO_BaseUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ZAIKO_BaseUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZAIKO_BasePayload>[]
        }
        upsert: {
          args: Prisma.ZAIKO_BaseUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ZAIKO_BasePayload>
        }
        aggregate: {
          args: Prisma.ZAIKO_BaseAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateZAIKO_Base>
        }
        groupBy: {
          args: Prisma.ZAIKO_BaseGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ZAIKO_BaseGroupByOutputType>[]
        }
        count: {
          args: Prisma.ZAIKO_BaseCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ZAIKO_BaseCountAggregateOutputType> | number
        }
      }
    }
    UpassFamilyTree: {
      payload: Prisma.$UpassFamilyTreePayload<ExtArgs>
      fields: Prisma.UpassFamilyTreeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UpassFamilyTreeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UpassFamilyTreePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UpassFamilyTreeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UpassFamilyTreePayload>
        }
        findFirst: {
          args: Prisma.UpassFamilyTreeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UpassFamilyTreePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UpassFamilyTreeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UpassFamilyTreePayload>
        }
        findMany: {
          args: Prisma.UpassFamilyTreeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UpassFamilyTreePayload>[]
        }
        create: {
          args: Prisma.UpassFamilyTreeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UpassFamilyTreePayload>
        }
        createMany: {
          args: Prisma.UpassFamilyTreeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UpassFamilyTreeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UpassFamilyTreePayload>[]
        }
        delete: {
          args: Prisma.UpassFamilyTreeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UpassFamilyTreePayload>
        }
        update: {
          args: Prisma.UpassFamilyTreeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UpassFamilyTreePayload>
        }
        deleteMany: {
          args: Prisma.UpassFamilyTreeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UpassFamilyTreeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UpassFamilyTreeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UpassFamilyTreePayload>[]
        }
        upsert: {
          args: Prisma.UpassFamilyTreeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UpassFamilyTreePayload>
        }
        aggregate: {
          args: Prisma.UpassFamilyTreeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUpassFamilyTree>
        }
        groupBy: {
          args: Prisma.UpassFamilyTreeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UpassFamilyTreeGroupByOutputType>[]
        }
        count: {
          args: Prisma.UpassFamilyTreeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UpassFamilyTreeCountAggregateOutputType> | number
        }
      }
    }
    UPASS: {
      payload: Prisma.$UPASSPayload<ExtArgs>
      fields: Prisma.UPASSFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UPASSFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UPASSPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UPASSFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UPASSPayload>
        }
        findFirst: {
          args: Prisma.UPASSFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UPASSPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UPASSFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UPASSPayload>
        }
        findMany: {
          args: Prisma.UPASSFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UPASSPayload>[]
        }
        create: {
          args: Prisma.UPASSCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UPASSPayload>
        }
        createMany: {
          args: Prisma.UPASSCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UPASSCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UPASSPayload>[]
        }
        delete: {
          args: Prisma.UPASSDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UPASSPayload>
        }
        update: {
          args: Prisma.UPASSUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UPASSPayload>
        }
        deleteMany: {
          args: Prisma.UPASSDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UPASSUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UPASSUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UPASSPayload>[]
        }
        upsert: {
          args: Prisma.UPASSUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UPASSPayload>
        }
        aggregate: {
          args: Prisma.UPASSAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUPASS>
        }
        groupBy: {
          args: Prisma.UPASSGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UPASSGroupByOutputType>[]
        }
        count: {
          args: Prisma.UPASSCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UPASSCountAggregateOutputType> | number
        }
      }
    }
    QR_Prosess: {
      payload: Prisma.$QR_ProsessPayload<ExtArgs>
      fields: Prisma.QR_ProsessFieldRefs
      operations: {
        findUnique: {
          args: Prisma.QR_ProsessFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QR_ProsessPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.QR_ProsessFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QR_ProsessPayload>
        }
        findFirst: {
          args: Prisma.QR_ProsessFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QR_ProsessPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.QR_ProsessFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QR_ProsessPayload>
        }
        findMany: {
          args: Prisma.QR_ProsessFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QR_ProsessPayload>[]
        }
        create: {
          args: Prisma.QR_ProsessCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QR_ProsessPayload>
        }
        createMany: {
          args: Prisma.QR_ProsessCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.QR_ProsessCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QR_ProsessPayload>[]
        }
        delete: {
          args: Prisma.QR_ProsessDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QR_ProsessPayload>
        }
        update: {
          args: Prisma.QR_ProsessUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QR_ProsessPayload>
        }
        deleteMany: {
          args: Prisma.QR_ProsessDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.QR_ProsessUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.QR_ProsessUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QR_ProsessPayload>[]
        }
        upsert: {
          args: Prisma.QR_ProsessUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$QR_ProsessPayload>
        }
        aggregate: {
          args: Prisma.QR_ProsessAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateQR_Prosess>
        }
        groupBy: {
          args: Prisma.QR_ProsessGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QR_ProsessGroupByOutputType>[]
        }
        count: {
          args: Prisma.QR_ProsessCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.QR_ProsessCountAggregateOutputType> | number
        }
      }
    }
    DeliverSchedule: {
      payload: Prisma.$DeliverSchedulePayload<ExtArgs>
      fields: Prisma.DeliverScheduleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DeliverScheduleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeliverSchedulePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DeliverScheduleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeliverSchedulePayload>
        }
        findFirst: {
          args: Prisma.DeliverScheduleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeliverSchedulePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DeliverScheduleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeliverSchedulePayload>
        }
        findMany: {
          args: Prisma.DeliverScheduleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeliverSchedulePayload>[]
        }
        create: {
          args: Prisma.DeliverScheduleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeliverSchedulePayload>
        }
        createMany: {
          args: Prisma.DeliverScheduleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DeliverScheduleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeliverSchedulePayload>[]
        }
        delete: {
          args: Prisma.DeliverScheduleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeliverSchedulePayload>
        }
        update: {
          args: Prisma.DeliverScheduleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeliverSchedulePayload>
        }
        deleteMany: {
          args: Prisma.DeliverScheduleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DeliverScheduleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DeliverScheduleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeliverSchedulePayload>[]
        }
        upsert: {
          args: Prisma.DeliverScheduleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DeliverSchedulePayload>
        }
        aggregate: {
          args: Prisma.DeliverScheduleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDeliverSchedule>
        }
        groupBy: {
          args: Prisma.DeliverScheduleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DeliverScheduleGroupByOutputType>[]
        }
        count: {
          args: Prisma.DeliverScheduleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DeliverScheduleCountAggregateOutputType> | number
        }
      }
    }
    Area: {
      payload: Prisma.$AreaPayload<ExtArgs>
      fields: Prisma.AreaFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AreaFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AreaFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaPayload>
        }
        findFirst: {
          args: Prisma.AreaFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AreaFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaPayload>
        }
        findMany: {
          args: Prisma.AreaFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaPayload>[]
        }
        create: {
          args: Prisma.AreaCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaPayload>
        }
        createMany: {
          args: Prisma.AreaCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AreaCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaPayload>[]
        }
        delete: {
          args: Prisma.AreaDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaPayload>
        }
        update: {
          args: Prisma.AreaUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaPayload>
        }
        deleteMany: {
          args: Prisma.AreaDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AreaUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AreaUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaPayload>[]
        }
        upsert: {
          args: Prisma.AreaUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AreaPayload>
        }
        aggregate: {
          args: Prisma.AreaAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateArea>
        }
        groupBy: {
          args: Prisma.AreaGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AreaGroupByOutputType>[]
        }
        count: {
          args: Prisma.AreaCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AreaCountAggregateOutputType> | number
        }
      }
    }
    LoadingVehicle: {
      payload: Prisma.$LoadingVehiclePayload<ExtArgs>
      fields: Prisma.LoadingVehicleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.LoadingVehicleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoadingVehiclePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.LoadingVehicleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoadingVehiclePayload>
        }
        findFirst: {
          args: Prisma.LoadingVehicleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoadingVehiclePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.LoadingVehicleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoadingVehiclePayload>
        }
        findMany: {
          args: Prisma.LoadingVehicleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoadingVehiclePayload>[]
        }
        create: {
          args: Prisma.LoadingVehicleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoadingVehiclePayload>
        }
        createMany: {
          args: Prisma.LoadingVehicleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.LoadingVehicleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoadingVehiclePayload>[]
        }
        delete: {
          args: Prisma.LoadingVehicleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoadingVehiclePayload>
        }
        update: {
          args: Prisma.LoadingVehicleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoadingVehiclePayload>
        }
        deleteMany: {
          args: Prisma.LoadingVehicleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.LoadingVehicleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.LoadingVehicleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoadingVehiclePayload>[]
        }
        upsert: {
          args: Prisma.LoadingVehicleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$LoadingVehiclePayload>
        }
        aggregate: {
          args: Prisma.LoadingVehicleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateLoadingVehicle>
        }
        groupBy: {
          args: Prisma.LoadingVehicleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LoadingVehicleGroupByOutputType>[]
        }
        count: {
          args: Prisma.LoadingVehicleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.LoadingVehicleCountAggregateOutputType> | number
        }
      }
    }
    Slot: {
      payload: Prisma.$SlotPayload<ExtArgs>
      fields: Prisma.SlotFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SlotFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SlotPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SlotFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SlotPayload>
        }
        findFirst: {
          args: Prisma.SlotFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SlotPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SlotFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SlotPayload>
        }
        findMany: {
          args: Prisma.SlotFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SlotPayload>[]
        }
        create: {
          args: Prisma.SlotCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SlotPayload>
        }
        createMany: {
          args: Prisma.SlotCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SlotCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SlotPayload>[]
        }
        delete: {
          args: Prisma.SlotDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SlotPayload>
        }
        update: {
          args: Prisma.SlotUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SlotPayload>
        }
        deleteMany: {
          args: Prisma.SlotDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SlotUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SlotUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SlotPayload>[]
        }
        upsert: {
          args: Prisma.SlotUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SlotPayload>
        }
        aggregate: {
          args: Prisma.SlotAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSlot>
        }
        groupBy: {
          args: Prisma.SlotGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SlotGroupByOutputType>[]
        }
        count: {
          args: Prisma.SlotCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SlotCountAggregateOutputType> | number
        }
      }
    }
    NewCar: {
      payload: Prisma.$NewCarPayload<ExtArgs>
      fields: Prisma.NewCarFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewCarFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewCarFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarPayload>
        }
        findFirst: {
          args: Prisma.NewCarFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewCarFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarPayload>
        }
        findMany: {
          args: Prisma.NewCarFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarPayload>[]
        }
        create: {
          args: Prisma.NewCarCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarPayload>
        }
        createMany: {
          args: Prisma.NewCarCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewCarCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarPayload>[]
        }
        delete: {
          args: Prisma.NewCarDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarPayload>
        }
        update: {
          args: Prisma.NewCarUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarPayload>
        }
        deleteMany: {
          args: Prisma.NewCarDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewCarUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewCarUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarPayload>[]
        }
        upsert: {
          args: Prisma.NewCarUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarPayload>
        }
        aggregate: {
          args: Prisma.NewCarAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewCar>
        }
        groupBy: {
          args: Prisma.NewCarGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewCarGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewCarCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewCarCountAggregateOutputType> | number
        }
      }
    }
    OrderSwitchingHisotory: {
      payload: Prisma.$OrderSwitchingHisotoryPayload<ExtArgs>
      fields: Prisma.OrderSwitchingHisotoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OrderSwitchingHisotoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderSwitchingHisotoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OrderSwitchingHisotoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderSwitchingHisotoryPayload>
        }
        findFirst: {
          args: Prisma.OrderSwitchingHisotoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderSwitchingHisotoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OrderSwitchingHisotoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderSwitchingHisotoryPayload>
        }
        findMany: {
          args: Prisma.OrderSwitchingHisotoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderSwitchingHisotoryPayload>[]
        }
        create: {
          args: Prisma.OrderSwitchingHisotoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderSwitchingHisotoryPayload>
        }
        createMany: {
          args: Prisma.OrderSwitchingHisotoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OrderSwitchingHisotoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderSwitchingHisotoryPayload>[]
        }
        delete: {
          args: Prisma.OrderSwitchingHisotoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderSwitchingHisotoryPayload>
        }
        update: {
          args: Prisma.OrderSwitchingHisotoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderSwitchingHisotoryPayload>
        }
        deleteMany: {
          args: Prisma.OrderSwitchingHisotoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OrderSwitchingHisotoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OrderSwitchingHisotoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderSwitchingHisotoryPayload>[]
        }
        upsert: {
          args: Prisma.OrderSwitchingHisotoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OrderSwitchingHisotoryPayload>
        }
        aggregate: {
          args: Prisma.OrderSwitchingHisotoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOrderSwitchingHisotory>
        }
        groupBy: {
          args: Prisma.OrderSwitchingHisotoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderSwitchingHisotoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.OrderSwitchingHisotoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OrderSwitchingHisotoryCountAggregateOutputType> | number
        }
      }
    }
    DesiredTorokuDate: {
      payload: Prisma.$DesiredTorokuDatePayload<ExtArgs>
      fields: Prisma.DesiredTorokuDateFieldRefs
      operations: {
        findUnique: {
          args: Prisma.DesiredTorokuDateFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DesiredTorokuDatePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.DesiredTorokuDateFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DesiredTorokuDatePayload>
        }
        findFirst: {
          args: Prisma.DesiredTorokuDateFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DesiredTorokuDatePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.DesiredTorokuDateFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DesiredTorokuDatePayload>
        }
        findMany: {
          args: Prisma.DesiredTorokuDateFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DesiredTorokuDatePayload>[]
        }
        create: {
          args: Prisma.DesiredTorokuDateCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DesiredTorokuDatePayload>
        }
        createMany: {
          args: Prisma.DesiredTorokuDateCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.DesiredTorokuDateCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DesiredTorokuDatePayload>[]
        }
        delete: {
          args: Prisma.DesiredTorokuDateDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DesiredTorokuDatePayload>
        }
        update: {
          args: Prisma.DesiredTorokuDateUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DesiredTorokuDatePayload>
        }
        deleteMany: {
          args: Prisma.DesiredTorokuDateDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.DesiredTorokuDateUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.DesiredTorokuDateUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DesiredTorokuDatePayload>[]
        }
        upsert: {
          args: Prisma.DesiredTorokuDateUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$DesiredTorokuDatePayload>
        }
        aggregate: {
          args: Prisma.DesiredTorokuDateAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateDesiredTorokuDate>
        }
        groupBy: {
          args: Prisma.DesiredTorokuDateGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DesiredTorokuDateGroupByOutputType>[]
        }
        count: {
          args: Prisma.DesiredTorokuDateCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.DesiredTorokuDateCountAggregateOutputType> | number
        }
      }
    }
    NewCarLeadTime: {
      payload: Prisma.$NewCarLeadTimePayload<ExtArgs>
      fields: Prisma.NewCarLeadTimeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.NewCarLeadTimeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarLeadTimePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.NewCarLeadTimeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarLeadTimePayload>
        }
        findFirst: {
          args: Prisma.NewCarLeadTimeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarLeadTimePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.NewCarLeadTimeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarLeadTimePayload>
        }
        findMany: {
          args: Prisma.NewCarLeadTimeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarLeadTimePayload>[]
        }
        create: {
          args: Prisma.NewCarLeadTimeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarLeadTimePayload>
        }
        createMany: {
          args: Prisma.NewCarLeadTimeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.NewCarLeadTimeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarLeadTimePayload>[]
        }
        delete: {
          args: Prisma.NewCarLeadTimeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarLeadTimePayload>
        }
        update: {
          args: Prisma.NewCarLeadTimeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarLeadTimePayload>
        }
        deleteMany: {
          args: Prisma.NewCarLeadTimeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.NewCarLeadTimeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.NewCarLeadTimeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarLeadTimePayload>[]
        }
        upsert: {
          args: Prisma.NewCarLeadTimeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$NewCarLeadTimePayload>
        }
        aggregate: {
          args: Prisma.NewCarLeadTimeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNewCarLeadTime>
        }
        groupBy: {
          args: Prisma.NewCarLeadTimeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewCarLeadTimeGroupByOutputType>[]
        }
        count: {
          args: Prisma.NewCarLeadTimeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.NewCarLeadTimeCountAggregateOutputType> | number
        }
      }
    }
    CrInspectionHistory: {
      payload: Prisma.$CrInspectionHistoryPayload<ExtArgs>
      fields: Prisma.CrInspectionHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CrInspectionHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrInspectionHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CrInspectionHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrInspectionHistoryPayload>
        }
        findFirst: {
          args: Prisma.CrInspectionHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrInspectionHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CrInspectionHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrInspectionHistoryPayload>
        }
        findMany: {
          args: Prisma.CrInspectionHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrInspectionHistoryPayload>[]
        }
        create: {
          args: Prisma.CrInspectionHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrInspectionHistoryPayload>
        }
        createMany: {
          args: Prisma.CrInspectionHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CrInspectionHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrInspectionHistoryPayload>[]
        }
        delete: {
          args: Prisma.CrInspectionHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrInspectionHistoryPayload>
        }
        update: {
          args: Prisma.CrInspectionHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrInspectionHistoryPayload>
        }
        deleteMany: {
          args: Prisma.CrInspectionHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CrInspectionHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CrInspectionHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrInspectionHistoryPayload>[]
        }
        upsert: {
          args: Prisma.CrInspectionHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CrInspectionHistoryPayload>
        }
        aggregate: {
          args: Prisma.CrInspectionHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCrInspectionHistory>
        }
        groupBy: {
          args: Prisma.CrInspectionHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CrInspectionHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.CrInspectionHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CrInspectionHistoryCountAggregateOutputType> | number
        }
      }
    }
    SeisanYoteiHistory: {
      payload: Prisma.$SeisanYoteiHistoryPayload<ExtArgs>
      fields: Prisma.SeisanYoteiHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.SeisanYoteiHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeisanYoteiHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.SeisanYoteiHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeisanYoteiHistoryPayload>
        }
        findFirst: {
          args: Prisma.SeisanYoteiHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeisanYoteiHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.SeisanYoteiHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeisanYoteiHistoryPayload>
        }
        findMany: {
          args: Prisma.SeisanYoteiHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeisanYoteiHistoryPayload>[]
        }
        create: {
          args: Prisma.SeisanYoteiHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeisanYoteiHistoryPayload>
        }
        createMany: {
          args: Prisma.SeisanYoteiHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.SeisanYoteiHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeisanYoteiHistoryPayload>[]
        }
        delete: {
          args: Prisma.SeisanYoteiHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeisanYoteiHistoryPayload>
        }
        update: {
          args: Prisma.SeisanYoteiHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeisanYoteiHistoryPayload>
        }
        deleteMany: {
          args: Prisma.SeisanYoteiHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.SeisanYoteiHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.SeisanYoteiHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeisanYoteiHistoryPayload>[]
        }
        upsert: {
          args: Prisma.SeisanYoteiHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$SeisanYoteiHistoryPayload>
        }
        aggregate: {
          args: Prisma.SeisanYoteiHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateSeisanYoteiHistory>
        }
        groupBy: {
          args: Prisma.SeisanYoteiHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SeisanYoteiHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.SeisanYoteiHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.SeisanYoteiHistoryCountAggregateOutputType> | number
        }
      }
    }
    UserProgressAggregationTable: {
      payload: Prisma.$UserProgressAggregationTablePayload<ExtArgs>
      fields: Prisma.UserProgressAggregationTableFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserProgressAggregationTableFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProgressAggregationTablePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserProgressAggregationTableFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProgressAggregationTablePayload>
        }
        findFirst: {
          args: Prisma.UserProgressAggregationTableFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProgressAggregationTablePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserProgressAggregationTableFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProgressAggregationTablePayload>
        }
        findMany: {
          args: Prisma.UserProgressAggregationTableFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProgressAggregationTablePayload>[]
        }
        create: {
          args: Prisma.UserProgressAggregationTableCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProgressAggregationTablePayload>
        }
        createMany: {
          args: Prisma.UserProgressAggregationTableCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserProgressAggregationTableCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProgressAggregationTablePayload>[]
        }
        delete: {
          args: Prisma.UserProgressAggregationTableDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProgressAggregationTablePayload>
        }
        update: {
          args: Prisma.UserProgressAggregationTableUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProgressAggregationTablePayload>
        }
        deleteMany: {
          args: Prisma.UserProgressAggregationTableDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserProgressAggregationTableUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserProgressAggregationTableUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProgressAggregationTablePayload>[]
        }
        upsert: {
          args: Prisma.UserProgressAggregationTableUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserProgressAggregationTablePayload>
        }
        aggregate: {
          args: Prisma.UserProgressAggregationTableAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserProgressAggregationTable>
        }
        groupBy: {
          args: Prisma.UserProgressAggregationTableGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserProgressAggregationTableGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserProgressAggregationTableCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserProgressAggregationTableCountAggregateOutputType> | number
        }
      }
    }
    ProgressAggregationTable: {
      payload: Prisma.$ProgressAggregationTablePayload<ExtArgs>
      fields: Prisma.ProgressAggregationTableFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgressAggregationTableFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTablePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgressAggregationTableFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTablePayload>
        }
        findFirst: {
          args: Prisma.ProgressAggregationTableFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTablePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgressAggregationTableFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTablePayload>
        }
        findMany: {
          args: Prisma.ProgressAggregationTableFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTablePayload>[]
        }
        create: {
          args: Prisma.ProgressAggregationTableCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTablePayload>
        }
        createMany: {
          args: Prisma.ProgressAggregationTableCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProgressAggregationTableCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTablePayload>[]
        }
        delete: {
          args: Prisma.ProgressAggregationTableDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTablePayload>
        }
        update: {
          args: Prisma.ProgressAggregationTableUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTablePayload>
        }
        deleteMany: {
          args: Prisma.ProgressAggregationTableDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgressAggregationTableUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProgressAggregationTableUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTablePayload>[]
        }
        upsert: {
          args: Prisma.ProgressAggregationTableUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTablePayload>
        }
        aggregate: {
          args: Prisma.ProgressAggregationTableAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgressAggregationTable>
        }
        groupBy: {
          args: Prisma.ProgressAggregationTableGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgressAggregationTableGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgressAggregationTableCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgressAggregationTableCountAggregateOutputType> | number
        }
      }
    }
    ProgressAggregationTableRecord: {
      payload: Prisma.$ProgressAggregationTableRecordPayload<ExtArgs>
      fields: Prisma.ProgressAggregationTableRecordFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ProgressAggregationTableRecordFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTableRecordPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ProgressAggregationTableRecordFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTableRecordPayload>
        }
        findFirst: {
          args: Prisma.ProgressAggregationTableRecordFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTableRecordPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ProgressAggregationTableRecordFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTableRecordPayload>
        }
        findMany: {
          args: Prisma.ProgressAggregationTableRecordFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTableRecordPayload>[]
        }
        create: {
          args: Prisma.ProgressAggregationTableRecordCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTableRecordPayload>
        }
        createMany: {
          args: Prisma.ProgressAggregationTableRecordCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ProgressAggregationTableRecordCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTableRecordPayload>[]
        }
        delete: {
          args: Prisma.ProgressAggregationTableRecordDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTableRecordPayload>
        }
        update: {
          args: Prisma.ProgressAggregationTableRecordUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTableRecordPayload>
        }
        deleteMany: {
          args: Prisma.ProgressAggregationTableRecordDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ProgressAggregationTableRecordUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ProgressAggregationTableRecordUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTableRecordPayload>[]
        }
        upsert: {
          args: Prisma.ProgressAggregationTableRecordUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ProgressAggregationTableRecordPayload>
        }
        aggregate: {
          args: Prisma.ProgressAggregationTableRecordAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateProgressAggregationTableRecord>
        }
        groupBy: {
          args: Prisma.ProgressAggregationTableRecordGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgressAggregationTableRecordGroupByOutputType>[]
        }
        count: {
          args: Prisma.ProgressAggregationTableRecordCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ProgressAggregationTableRecordCountAggregateOutputType> | number
        }
      }
    }
    FuriateStatusOnApprovement: {
      payload: Prisma.$FuriateStatusOnApprovementPayload<ExtArgs>
      fields: Prisma.FuriateStatusOnApprovementFieldRefs
      operations: {
        findUnique: {
          args: Prisma.FuriateStatusOnApprovementFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuriateStatusOnApprovementPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.FuriateStatusOnApprovementFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuriateStatusOnApprovementPayload>
        }
        findFirst: {
          args: Prisma.FuriateStatusOnApprovementFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuriateStatusOnApprovementPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.FuriateStatusOnApprovementFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuriateStatusOnApprovementPayload>
        }
        findMany: {
          args: Prisma.FuriateStatusOnApprovementFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuriateStatusOnApprovementPayload>[]
        }
        create: {
          args: Prisma.FuriateStatusOnApprovementCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuriateStatusOnApprovementPayload>
        }
        createMany: {
          args: Prisma.FuriateStatusOnApprovementCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.FuriateStatusOnApprovementCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuriateStatusOnApprovementPayload>[]
        }
        delete: {
          args: Prisma.FuriateStatusOnApprovementDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuriateStatusOnApprovementPayload>
        }
        update: {
          args: Prisma.FuriateStatusOnApprovementUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuriateStatusOnApprovementPayload>
        }
        deleteMany: {
          args: Prisma.FuriateStatusOnApprovementDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.FuriateStatusOnApprovementUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.FuriateStatusOnApprovementUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuriateStatusOnApprovementPayload>[]
        }
        upsert: {
          args: Prisma.FuriateStatusOnApprovementUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$FuriateStatusOnApprovementPayload>
        }
        aggregate: {
          args: Prisma.FuriateStatusOnApprovementAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateFuriateStatusOnApprovement>
        }
        groupBy: {
          args: Prisma.FuriateStatusOnApprovementGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FuriateStatusOnApprovementGroupByOutputType>[]
        }
        count: {
          args: Prisma.FuriateStatusOnApprovementCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.FuriateStatusOnApprovementCountAggregateOutputType> | number
        }
      }
    }
    CarTransferHistory: {
      payload: Prisma.$CarTransferHistoryPayload<ExtArgs>
      fields: Prisma.CarTransferHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CarTransferHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarTransferHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CarTransferHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarTransferHistoryPayload>
        }
        findFirst: {
          args: Prisma.CarTransferHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarTransferHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CarTransferHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarTransferHistoryPayload>
        }
        findMany: {
          args: Prisma.CarTransferHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarTransferHistoryPayload>[]
        }
        create: {
          args: Prisma.CarTransferHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarTransferHistoryPayload>
        }
        createMany: {
          args: Prisma.CarTransferHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CarTransferHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarTransferHistoryPayload>[]
        }
        delete: {
          args: Prisma.CarTransferHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarTransferHistoryPayload>
        }
        update: {
          args: Prisma.CarTransferHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarTransferHistoryPayload>
        }
        deleteMany: {
          args: Prisma.CarTransferHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CarTransferHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CarTransferHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarTransferHistoryPayload>[]
        }
        upsert: {
          args: Prisma.CarTransferHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CarTransferHistoryPayload>
        }
        aggregate: {
          args: Prisma.CarTransferHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCarTransferHistory>
        }
        groupBy: {
          args: Prisma.CarTransferHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CarTransferHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.CarTransferHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CarTransferHistoryCountAggregateOutputType> | number
        }
      }
    }
    TenpoTsuikoShinseiHeader: {
      payload: Prisma.$TenpoTsuikoShinseiHeaderPayload<ExtArgs>
      fields: Prisma.TenpoTsuikoShinseiHeaderFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenpoTsuikoShinseiHeaderFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiHeaderPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenpoTsuikoShinseiHeaderFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiHeaderPayload>
        }
        findFirst: {
          args: Prisma.TenpoTsuikoShinseiHeaderFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiHeaderPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenpoTsuikoShinseiHeaderFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiHeaderPayload>
        }
        findMany: {
          args: Prisma.TenpoTsuikoShinseiHeaderFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiHeaderPayload>[]
        }
        create: {
          args: Prisma.TenpoTsuikoShinseiHeaderCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiHeaderPayload>
        }
        createMany: {
          args: Prisma.TenpoTsuikoShinseiHeaderCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenpoTsuikoShinseiHeaderCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiHeaderPayload>[]
        }
        delete: {
          args: Prisma.TenpoTsuikoShinseiHeaderDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiHeaderPayload>
        }
        update: {
          args: Prisma.TenpoTsuikoShinseiHeaderUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiHeaderPayload>
        }
        deleteMany: {
          args: Prisma.TenpoTsuikoShinseiHeaderDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenpoTsuikoShinseiHeaderUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenpoTsuikoShinseiHeaderUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiHeaderPayload>[]
        }
        upsert: {
          args: Prisma.TenpoTsuikoShinseiHeaderUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiHeaderPayload>
        }
        aggregate: {
          args: Prisma.TenpoTsuikoShinseiHeaderAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenpoTsuikoShinseiHeader>
        }
        groupBy: {
          args: Prisma.TenpoTsuikoShinseiHeaderGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenpoTsuikoShinseiHeaderGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenpoTsuikoShinseiHeaderCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenpoTsuikoShinseiHeaderCountAggregateOutputType> | number
        }
      }
    }
    TenpoTsuikoShinseiDetail: {
      payload: Prisma.$TenpoTsuikoShinseiDetailPayload<ExtArgs>
      fields: Prisma.TenpoTsuikoShinseiDetailFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenpoTsuikoShinseiDetailFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiDetailPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenpoTsuikoShinseiDetailFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiDetailPayload>
        }
        findFirst: {
          args: Prisma.TenpoTsuikoShinseiDetailFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiDetailPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenpoTsuikoShinseiDetailFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiDetailPayload>
        }
        findMany: {
          args: Prisma.TenpoTsuikoShinseiDetailFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiDetailPayload>[]
        }
        create: {
          args: Prisma.TenpoTsuikoShinseiDetailCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiDetailPayload>
        }
        createMany: {
          args: Prisma.TenpoTsuikoShinseiDetailCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenpoTsuikoShinseiDetailCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiDetailPayload>[]
        }
        delete: {
          args: Prisma.TenpoTsuikoShinseiDetailDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiDetailPayload>
        }
        update: {
          args: Prisma.TenpoTsuikoShinseiDetailUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiDetailPayload>
        }
        deleteMany: {
          args: Prisma.TenpoTsuikoShinseiDetailDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenpoTsuikoShinseiDetailUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenpoTsuikoShinseiDetailUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiDetailPayload>[]
        }
        upsert: {
          args: Prisma.TenpoTsuikoShinseiDetailUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoShinseiDetailPayload>
        }
        aggregate: {
          args: Prisma.TenpoTsuikoShinseiDetailAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenpoTsuikoShinseiDetail>
        }
        groupBy: {
          args: Prisma.TenpoTsuikoShinseiDetailGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenpoTsuikoShinseiDetailGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenpoTsuikoShinseiDetailCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenpoTsuikoShinseiDetailCountAggregateOutputType> | number
        }
      }
    }
    TenpoTsuikoData: {
      payload: Prisma.$TenpoTsuikoDataPayload<ExtArgs>
      fields: Prisma.TenpoTsuikoDataFieldRefs
      operations: {
        findUnique: {
          args: Prisma.TenpoTsuikoDataFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoDataPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.TenpoTsuikoDataFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoDataPayload>
        }
        findFirst: {
          args: Prisma.TenpoTsuikoDataFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoDataPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.TenpoTsuikoDataFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoDataPayload>
        }
        findMany: {
          args: Prisma.TenpoTsuikoDataFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoDataPayload>[]
        }
        create: {
          args: Prisma.TenpoTsuikoDataCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoDataPayload>
        }
        createMany: {
          args: Prisma.TenpoTsuikoDataCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.TenpoTsuikoDataCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoDataPayload>[]
        }
        delete: {
          args: Prisma.TenpoTsuikoDataDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoDataPayload>
        }
        update: {
          args: Prisma.TenpoTsuikoDataUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoDataPayload>
        }
        deleteMany: {
          args: Prisma.TenpoTsuikoDataDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.TenpoTsuikoDataUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.TenpoTsuikoDataUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoDataPayload>[]
        }
        upsert: {
          args: Prisma.TenpoTsuikoDataUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$TenpoTsuikoDataPayload>
        }
        aggregate: {
          args: Prisma.TenpoTsuikoDataAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateTenpoTsuikoData>
        }
        groupBy: {
          args: Prisma.TenpoTsuikoDataGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenpoTsuikoDataGroupByOutputType>[]
        }
        count: {
          args: Prisma.TenpoTsuikoDataCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.TenpoTsuikoDataCountAggregateOutputType> | number
        }
      }
    }
    Store: {
      payload: Prisma.$StorePayload<ExtArgs>
      fields: Prisma.StoreFieldRefs
      operations: {
        findUnique: {
          args: Prisma.StoreFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.StoreFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorePayload>
        }
        findFirst: {
          args: Prisma.StoreFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.StoreFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorePayload>
        }
        findMany: {
          args: Prisma.StoreFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorePayload>[]
        }
        create: {
          args: Prisma.StoreCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorePayload>
        }
        createMany: {
          args: Prisma.StoreCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.StoreCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorePayload>[]
        }
        delete: {
          args: Prisma.StoreDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorePayload>
        }
        update: {
          args: Prisma.StoreUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorePayload>
        }
        deleteMany: {
          args: Prisma.StoreDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.StoreUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.StoreUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorePayload>[]
        }
        upsert: {
          args: Prisma.StoreUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$StorePayload>
        }
        aggregate: {
          args: Prisma.StoreAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateStore>
        }
        groupBy: {
          args: Prisma.StoreGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StoreGroupByOutputType>[]
        }
        count: {
          args: Prisma.StoreCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.StoreCountAggregateOutputType> | number
        }
      }
    }
    User: {
      payload: Prisma.$UserPayload<ExtArgs>
      fields: Prisma.UserFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findFirst: {
          args: Prisma.UserFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        findMany: {
          args: Prisma.UserFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        create: {
          args: Prisma.UserCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        createMany: {
          args: Prisma.UserCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        delete: {
          args: Prisma.UserDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        update: {
          args: Prisma.UserUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        deleteMany: {
          args: Prisma.UserDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>[]
        }
        upsert: {
          args: Prisma.UserUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserPayload>
        }
        aggregate: {
          args: Prisma.UserAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUser>
        }
        groupBy: {
          args: Prisma.UserGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserCountAggregateOutputType> | number
        }
      }
    }
    GoogleAccessToken: {
      payload: Prisma.$GoogleAccessTokenPayload<ExtArgs>
      fields: Prisma.GoogleAccessTokenFieldRefs
      operations: {
        findUnique: {
          args: Prisma.GoogleAccessTokenFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoogleAccessTokenPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.GoogleAccessTokenFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoogleAccessTokenPayload>
        }
        findFirst: {
          args: Prisma.GoogleAccessTokenFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoogleAccessTokenPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.GoogleAccessTokenFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoogleAccessTokenPayload>
        }
        findMany: {
          args: Prisma.GoogleAccessTokenFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoogleAccessTokenPayload>[]
        }
        create: {
          args: Prisma.GoogleAccessTokenCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoogleAccessTokenPayload>
        }
        createMany: {
          args: Prisma.GoogleAccessTokenCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.GoogleAccessTokenCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoogleAccessTokenPayload>[]
        }
        delete: {
          args: Prisma.GoogleAccessTokenDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoogleAccessTokenPayload>
        }
        update: {
          args: Prisma.GoogleAccessTokenUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoogleAccessTokenPayload>
        }
        deleteMany: {
          args: Prisma.GoogleAccessTokenDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.GoogleAccessTokenUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.GoogleAccessTokenUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoogleAccessTokenPayload>[]
        }
        upsert: {
          args: Prisma.GoogleAccessTokenUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$GoogleAccessTokenPayload>
        }
        aggregate: {
          args: Prisma.GoogleAccessTokenAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateGoogleAccessToken>
        }
        groupBy: {
          args: Prisma.GoogleAccessTokenGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GoogleAccessTokenGroupByOutputType>[]
        }
        count: {
          args: Prisma.GoogleAccessTokenCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.GoogleAccessTokenCountAggregateOutputType> | number
        }
      }
    }
    RoleMaster: {
      payload: Prisma.$RoleMasterPayload<ExtArgs>
      fields: Prisma.RoleMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RoleMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RoleMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleMasterPayload>
        }
        findFirst: {
          args: Prisma.RoleMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RoleMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleMasterPayload>
        }
        findMany: {
          args: Prisma.RoleMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleMasterPayload>[]
        }
        create: {
          args: Prisma.RoleMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleMasterPayload>
        }
        createMany: {
          args: Prisma.RoleMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RoleMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleMasterPayload>[]
        }
        delete: {
          args: Prisma.RoleMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleMasterPayload>
        }
        update: {
          args: Prisma.RoleMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleMasterPayload>
        }
        deleteMany: {
          args: Prisma.RoleMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RoleMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RoleMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleMasterPayload>[]
        }
        upsert: {
          args: Prisma.RoleMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RoleMasterPayload>
        }
        aggregate: {
          args: Prisma.RoleMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRoleMaster>
        }
        groupBy: {
          args: Prisma.RoleMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.RoleMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RoleMasterCountAggregateOutputType> | number
        }
      }
    }
    UserRole: {
      payload: Prisma.$UserRolePayload<ExtArgs>
      fields: Prisma.UserRoleFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        findFirst: {
          args: Prisma.UserRoleFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        findMany: {
          args: Prisma.UserRoleFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[]
        }
        create: {
          args: Prisma.UserRoleCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        createMany: {
          args: Prisma.UserRoleCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UserRoleCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[]
        }
        delete: {
          args: Prisma.UserRoleDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        update: {
          args: Prisma.UserRoleUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        deleteMany: {
          args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UserRoleUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>[]
        }
        upsert: {
          args: Prisma.UserRoleUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UserRolePayload>
        }
        aggregate: {
          args: Prisma.UserRoleAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUserRole>
        }
        groupBy: {
          args: Prisma.UserRoleGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserRoleGroupByOutputType>[]
        }
        count: {
          args: Prisma.UserRoleCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UserRoleCountAggregateOutputType> | number
        }
      }
    }
    Calendar: {
      payload: Prisma.$CalendarPayload<ExtArgs>
      fields: Prisma.CalendarFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CalendarFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CalendarFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>
        }
        findFirst: {
          args: Prisma.CalendarFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CalendarFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>
        }
        findMany: {
          args: Prisma.CalendarFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>[]
        }
        create: {
          args: Prisma.CalendarCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>
        }
        createMany: {
          args: Prisma.CalendarCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CalendarCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>[]
        }
        delete: {
          args: Prisma.CalendarDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>
        }
        update: {
          args: Prisma.CalendarUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>
        }
        deleteMany: {
          args: Prisma.CalendarDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CalendarUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CalendarUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>[]
        }
        upsert: {
          args: Prisma.CalendarUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CalendarPayload>
        }
        aggregate: {
          args: Prisma.CalendarAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCalendar>
        }
        groupBy: {
          args: Prisma.CalendarGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CalendarGroupByOutputType>[]
        }
        count: {
          args: Prisma.CalendarCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CalendarCountAggregateOutputType> | number
        }
      }
    }
    ChainMethodLock: {
      payload: Prisma.$ChainMethodLockPayload<ExtArgs>
      fields: Prisma.ChainMethodLockFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ChainMethodLockFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChainMethodLockPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ChainMethodLockFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChainMethodLockPayload>
        }
        findFirst: {
          args: Prisma.ChainMethodLockFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChainMethodLockPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ChainMethodLockFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChainMethodLockPayload>
        }
        findMany: {
          args: Prisma.ChainMethodLockFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChainMethodLockPayload>[]
        }
        create: {
          args: Prisma.ChainMethodLockCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChainMethodLockPayload>
        }
        createMany: {
          args: Prisma.ChainMethodLockCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ChainMethodLockCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChainMethodLockPayload>[]
        }
        delete: {
          args: Prisma.ChainMethodLockDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChainMethodLockPayload>
        }
        update: {
          args: Prisma.ChainMethodLockUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChainMethodLockPayload>
        }
        deleteMany: {
          args: Prisma.ChainMethodLockDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ChainMethodLockUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ChainMethodLockUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChainMethodLockPayload>[]
        }
        upsert: {
          args: Prisma.ChainMethodLockUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ChainMethodLockPayload>
        }
        aggregate: {
          args: Prisma.ChainMethodLockAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateChainMethodLock>
        }
        groupBy: {
          args: Prisma.ChainMethodLockGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChainMethodLockGroupByOutputType>[]
        }
        count: {
          args: Prisma.ChainMethodLockCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ChainMethodLockCountAggregateOutputType> | number
        }
      }
    }
    CronExecutionLog: {
      payload: Prisma.$CronExecutionLogPayload<ExtArgs>
      fields: Prisma.CronExecutionLogFieldRefs
      operations: {
        findUnique: {
          args: Prisma.CronExecutionLogFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CronExecutionLogPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.CronExecutionLogFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CronExecutionLogPayload>
        }
        findFirst: {
          args: Prisma.CronExecutionLogFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CronExecutionLogPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.CronExecutionLogFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CronExecutionLogPayload>
        }
        findMany: {
          args: Prisma.CronExecutionLogFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CronExecutionLogPayload>[]
        }
        create: {
          args: Prisma.CronExecutionLogCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CronExecutionLogPayload>
        }
        createMany: {
          args: Prisma.CronExecutionLogCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.CronExecutionLogCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CronExecutionLogPayload>[]
        }
        delete: {
          args: Prisma.CronExecutionLogDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CronExecutionLogPayload>
        }
        update: {
          args: Prisma.CronExecutionLogUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CronExecutionLogPayload>
        }
        deleteMany: {
          args: Prisma.CronExecutionLogDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.CronExecutionLogUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.CronExecutionLogUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CronExecutionLogPayload>[]
        }
        upsert: {
          args: Prisma.CronExecutionLogUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$CronExecutionLogPayload>
        }
        aggregate: {
          args: Prisma.CronExecutionLogAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateCronExecutionLog>
        }
        groupBy: {
          args: Prisma.CronExecutionLogGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CronExecutionLogGroupByOutputType>[]
        }
        count: {
          args: Prisma.CronExecutionLogCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.CronExecutionLogCountAggregateOutputType> | number
        }
      }
    }
    RentaStore: {
      payload: Prisma.$RentaStorePayload<ExtArgs>
      fields: Prisma.RentaStoreFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RentaStoreFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaStorePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RentaStoreFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaStorePayload>
        }
        findFirst: {
          args: Prisma.RentaStoreFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaStorePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RentaStoreFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaStorePayload>
        }
        findMany: {
          args: Prisma.RentaStoreFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaStorePayload>[]
        }
        create: {
          args: Prisma.RentaStoreCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaStorePayload>
        }
        createMany: {
          args: Prisma.RentaStoreCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RentaStoreCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaStorePayload>[]
        }
        delete: {
          args: Prisma.RentaStoreDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaStorePayload>
        }
        update: {
          args: Prisma.RentaStoreUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaStorePayload>
        }
        deleteMany: {
          args: Prisma.RentaStoreDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RentaStoreUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RentaStoreUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaStorePayload>[]
        }
        upsert: {
          args: Prisma.RentaStoreUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaStorePayload>
        }
        aggregate: {
          args: Prisma.RentaStoreAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRentaStore>
        }
        groupBy: {
          args: Prisma.RentaStoreGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentaStoreGroupByOutputType>[]
        }
        count: {
          args: Prisma.RentaStoreCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentaStoreCountAggregateOutputType> | number
        }
      }
    }
    RentaDeal: {
      payload: Prisma.$RentaDealPayload<ExtArgs>
      fields: Prisma.RentaDealFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RentaDealFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDealPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RentaDealFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDealPayload>
        }
        findFirst: {
          args: Prisma.RentaDealFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDealPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RentaDealFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDealPayload>
        }
        findMany: {
          args: Prisma.RentaDealFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDealPayload>[]
        }
        create: {
          args: Prisma.RentaDealCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDealPayload>
        }
        createMany: {
          args: Prisma.RentaDealCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RentaDealCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDealPayload>[]
        }
        delete: {
          args: Prisma.RentaDealDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDealPayload>
        }
        update: {
          args: Prisma.RentaDealUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDealPayload>
        }
        deleteMany: {
          args: Prisma.RentaDealDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RentaDealUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RentaDealUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDealPayload>[]
        }
        upsert: {
          args: Prisma.RentaDealUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDealPayload>
        }
        aggregate: {
          args: Prisma.RentaDealAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRentaDeal>
        }
        groupBy: {
          args: Prisma.RentaDealGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentaDealGroupByOutputType>[]
        }
        count: {
          args: Prisma.RentaDealCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentaDealCountAggregateOutputType> | number
        }
      }
    }
    RentaDailyReport: {
      payload: Prisma.$RentaDailyReportPayload<ExtArgs>
      fields: Prisma.RentaDailyReportFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RentaDailyReportFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDailyReportPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RentaDailyReportFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDailyReportPayload>
        }
        findFirst: {
          args: Prisma.RentaDailyReportFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDailyReportPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RentaDailyReportFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDailyReportPayload>
        }
        findMany: {
          args: Prisma.RentaDailyReportFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDailyReportPayload>[]
        }
        create: {
          args: Prisma.RentaDailyReportCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDailyReportPayload>
        }
        createMany: {
          args: Prisma.RentaDailyReportCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RentaDailyReportCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDailyReportPayload>[]
        }
        delete: {
          args: Prisma.RentaDailyReportDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDailyReportPayload>
        }
        update: {
          args: Prisma.RentaDailyReportUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDailyReportPayload>
        }
        deleteMany: {
          args: Prisma.RentaDailyReportDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RentaDailyReportUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RentaDailyReportUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDailyReportPayload>[]
        }
        upsert: {
          args: Prisma.RentaDailyReportUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaDailyReportPayload>
        }
        aggregate: {
          args: Prisma.RentaDailyReportAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRentaDailyReport>
        }
        groupBy: {
          args: Prisma.RentaDailyReportGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentaDailyReportGroupByOutputType>[]
        }
        count: {
          args: Prisma.RentaDailyReportCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentaDailyReportCountAggregateOutputType> | number
        }
      }
    }
    RentaCustomer: {
      payload: Prisma.$RentaCustomerPayload<ExtArgs>
      fields: Prisma.RentaCustomerFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RentaCustomerFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaCustomerPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RentaCustomerFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaCustomerPayload>
        }
        findFirst: {
          args: Prisma.RentaCustomerFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaCustomerPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RentaCustomerFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaCustomerPayload>
        }
        findMany: {
          args: Prisma.RentaCustomerFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaCustomerPayload>[]
        }
        create: {
          args: Prisma.RentaCustomerCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaCustomerPayload>
        }
        createMany: {
          args: Prisma.RentaCustomerCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RentaCustomerCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaCustomerPayload>[]
        }
        delete: {
          args: Prisma.RentaCustomerDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaCustomerPayload>
        }
        update: {
          args: Prisma.RentaCustomerUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaCustomerPayload>
        }
        deleteMany: {
          args: Prisma.RentaCustomerDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RentaCustomerUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RentaCustomerUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaCustomerPayload>[]
        }
        upsert: {
          args: Prisma.RentaCustomerUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaCustomerPayload>
        }
        aggregate: {
          args: Prisma.RentaCustomerAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRentaCustomer>
        }
        groupBy: {
          args: Prisma.RentaCustomerGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentaCustomerGroupByOutputType>[]
        }
        count: {
          args: Prisma.RentaCustomerCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentaCustomerCountAggregateOutputType> | number
        }
      }
    }
    RentaReference: {
      payload: Prisma.$RentaReferencePayload<ExtArgs>
      fields: Prisma.RentaReferenceFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RentaReferenceFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaReferencePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RentaReferenceFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaReferencePayload>
        }
        findFirst: {
          args: Prisma.RentaReferenceFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaReferencePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RentaReferenceFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaReferencePayload>
        }
        findMany: {
          args: Prisma.RentaReferenceFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaReferencePayload>[]
        }
        create: {
          args: Prisma.RentaReferenceCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaReferencePayload>
        }
        createMany: {
          args: Prisma.RentaReferenceCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RentaReferenceCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaReferencePayload>[]
        }
        delete: {
          args: Prisma.RentaReferenceDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaReferencePayload>
        }
        update: {
          args: Prisma.RentaReferenceUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaReferencePayload>
        }
        deleteMany: {
          args: Prisma.RentaReferenceDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RentaReferenceUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RentaReferenceUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaReferencePayload>[]
        }
        upsert: {
          args: Prisma.RentaReferenceUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RentaReferencePayload>
        }
        aggregate: {
          args: Prisma.RentaReferenceAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRentaReference>
        }
        groupBy: {
          args: Prisma.RentaReferenceGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentaReferenceGroupByOutputType>[]
        }
        count: {
          args: Prisma.RentaReferenceCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RentaReferenceCountAggregateOutputType> | number
        }
      }
    }
    RefFrom: {
      payload: Prisma.$RefFromPayload<ExtArgs>
      fields: Prisma.RefFromFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RefFromFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefFromPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RefFromFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefFromPayload>
        }
        findFirst: {
          args: Prisma.RefFromFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefFromPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RefFromFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefFromPayload>
        }
        findMany: {
          args: Prisma.RefFromFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefFromPayload>[]
        }
        create: {
          args: Prisma.RefFromCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefFromPayload>
        }
        createMany: {
          args: Prisma.RefFromCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RefFromCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefFromPayload>[]
        }
        delete: {
          args: Prisma.RefFromDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefFromPayload>
        }
        update: {
          args: Prisma.RefFromUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefFromPayload>
        }
        deleteMany: {
          args: Prisma.RefFromDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RefFromUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RefFromUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefFromPayload>[]
        }
        upsert: {
          args: Prisma.RefFromUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefFromPayload>
        }
        aggregate: {
          args: Prisma.RefFromAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRefFrom>
        }
        groupBy: {
          args: Prisma.RefFromGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefFromGroupByOutputType>[]
        }
        count: {
          args: Prisma.RefFromCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefFromCountAggregateOutputType> | number
        }
      }
    }
    RefTo: {
      payload: Prisma.$RefToPayload<ExtArgs>
      fields: Prisma.RefToFieldRefs
      operations: {
        findUnique: {
          args: Prisma.RefToFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefToPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.RefToFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefToPayload>
        }
        findFirst: {
          args: Prisma.RefToFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefToPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.RefToFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefToPayload>
        }
        findMany: {
          args: Prisma.RefToFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefToPayload>[]
        }
        create: {
          args: Prisma.RefToCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefToPayload>
        }
        createMany: {
          args: Prisma.RefToCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.RefToCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefToPayload>[]
        }
        delete: {
          args: Prisma.RefToDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefToPayload>
        }
        update: {
          args: Prisma.RefToUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefToPayload>
        }
        deleteMany: {
          args: Prisma.RefToDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.RefToUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.RefToUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefToPayload>[]
        }
        upsert: {
          args: Prisma.RefToUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$RefToPayload>
        }
        aggregate: {
          args: Prisma.RefToAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateRefTo>
        }
        groupBy: {
          args: Prisma.RefToGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefToGroupByOutputType>[]
        }
        count: {
          args: Prisma.RefToCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.RefToCountAggregateOutputType> | number
        }
      }
    }
    Purpose: {
      payload: Prisma.$PurposePayload<ExtArgs>
      fields: Prisma.PurposeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PurposeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PurposeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposePayload>
        }
        findFirst: {
          args: Prisma.PurposeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PurposeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposePayload>
        }
        findMany: {
          args: Prisma.PurposeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposePayload>[]
        }
        create: {
          args: Prisma.PurposeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposePayload>
        }
        createMany: {
          args: Prisma.PurposeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PurposeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposePayload>[]
        }
        delete: {
          args: Prisma.PurposeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposePayload>
        }
        update: {
          args: Prisma.PurposeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposePayload>
        }
        deleteMany: {
          args: Prisma.PurposeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PurposeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PurposeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposePayload>[]
        }
        upsert: {
          args: Prisma.PurposeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposePayload>
        }
        aggregate: {
          args: Prisma.PurposeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePurpose>
        }
        groupBy: {
          args: Prisma.PurposeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurposeGroupByOutputType>[]
        }
        count: {
          args: Prisma.PurposeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurposeCountAggregateOutputType> | number
        }
      }
    }
    PurposeMaster: {
      payload: Prisma.$PurposeMasterPayload<ExtArgs>
      fields: Prisma.PurposeMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.PurposeMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposeMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.PurposeMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposeMasterPayload>
        }
        findFirst: {
          args: Prisma.PurposeMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposeMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.PurposeMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposeMasterPayload>
        }
        findMany: {
          args: Prisma.PurposeMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposeMasterPayload>[]
        }
        create: {
          args: Prisma.PurposeMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposeMasterPayload>
        }
        createMany: {
          args: Prisma.PurposeMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.PurposeMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposeMasterPayload>[]
        }
        delete: {
          args: Prisma.PurposeMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposeMasterPayload>
        }
        update: {
          args: Prisma.PurposeMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposeMasterPayload>
        }
        deleteMany: {
          args: Prisma.PurposeMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.PurposeMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.PurposeMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposeMasterPayload>[]
        }
        upsert: {
          args: Prisma.PurposeMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$PurposeMasterPayload>
        }
        aggregate: {
          args: Prisma.PurposeMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregatePurposeMaster>
        }
        groupBy: {
          args: Prisma.PurposeMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurposeMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.PurposeMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.PurposeMasterCountAggregateOutputType> | number
        }
      }
    }
    Outcome: {
      payload: Prisma.$OutcomePayload<ExtArgs>
      fields: Prisma.OutcomeFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OutcomeFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomePayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OutcomeFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomePayload>
        }
        findFirst: {
          args: Prisma.OutcomeFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomePayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OutcomeFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomePayload>
        }
        findMany: {
          args: Prisma.OutcomeFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomePayload>[]
        }
        create: {
          args: Prisma.OutcomeCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomePayload>
        }
        createMany: {
          args: Prisma.OutcomeCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OutcomeCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomePayload>[]
        }
        delete: {
          args: Prisma.OutcomeDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomePayload>
        }
        update: {
          args: Prisma.OutcomeUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomePayload>
        }
        deleteMany: {
          args: Prisma.OutcomeDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OutcomeUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OutcomeUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomePayload>[]
        }
        upsert: {
          args: Prisma.OutcomeUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomePayload>
        }
        aggregate: {
          args: Prisma.OutcomeAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOutcome>
        }
        groupBy: {
          args: Prisma.OutcomeGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OutcomeGroupByOutputType>[]
        }
        count: {
          args: Prisma.OutcomeCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OutcomeCountAggregateOutputType> | number
        }
      }
    }
    OutcomeMaster: {
      payload: Prisma.$OutcomeMasterPayload<ExtArgs>
      fields: Prisma.OutcomeMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.OutcomeMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomeMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.OutcomeMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomeMasterPayload>
        }
        findFirst: {
          args: Prisma.OutcomeMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomeMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.OutcomeMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomeMasterPayload>
        }
        findMany: {
          args: Prisma.OutcomeMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomeMasterPayload>[]
        }
        create: {
          args: Prisma.OutcomeMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomeMasterPayload>
        }
        createMany: {
          args: Prisma.OutcomeMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.OutcomeMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomeMasterPayload>[]
        }
        delete: {
          args: Prisma.OutcomeMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomeMasterPayload>
        }
        update: {
          args: Prisma.OutcomeMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomeMasterPayload>
        }
        deleteMany: {
          args: Prisma.OutcomeMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.OutcomeMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.OutcomeMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomeMasterPayload>[]
        }
        upsert: {
          args: Prisma.OutcomeMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$OutcomeMasterPayload>
        }
        aggregate: {
          args: Prisma.OutcomeMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateOutcomeMaster>
        }
        groupBy: {
          args: Prisma.OutcomeMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OutcomeMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.OutcomeMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.OutcomeMasterCountAggregateOutputType> | number
        }
      }
    }
    AlternateInfo: {
      payload: Prisma.$AlternateInfoPayload<ExtArgs>
      fields: Prisma.AlternateInfoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AlternateInfoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlternateInfoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AlternateInfoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlternateInfoPayload>
        }
        findFirst: {
          args: Prisma.AlternateInfoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlternateInfoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AlternateInfoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlternateInfoPayload>
        }
        findMany: {
          args: Prisma.AlternateInfoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlternateInfoPayload>[]
        }
        create: {
          args: Prisma.AlternateInfoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlternateInfoPayload>
        }
        createMany: {
          args: Prisma.AlternateInfoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AlternateInfoCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlternateInfoPayload>[]
        }
        delete: {
          args: Prisma.AlternateInfoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlternateInfoPayload>
        }
        update: {
          args: Prisma.AlternateInfoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlternateInfoPayload>
        }
        deleteMany: {
          args: Prisma.AlternateInfoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AlternateInfoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AlternateInfoUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlternateInfoPayload>[]
        }
        upsert: {
          args: Prisma.AlternateInfoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AlternateInfoPayload>
        }
        aggregate: {
          args: Prisma.AlternateInfoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAlternateInfo>
        }
        groupBy: {
          args: Prisma.AlternateInfoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AlternateInfoGroupByOutputType>[]
        }
        count: {
          args: Prisma.AlternateInfoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AlternateInfoCountAggregateOutputType> | number
        }
      }
    }
    InsuranceInfo: {
      payload: Prisma.$InsuranceInfoPayload<ExtArgs>
      fields: Prisma.InsuranceInfoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.InsuranceInfoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceInfoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.InsuranceInfoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceInfoPayload>
        }
        findFirst: {
          args: Prisma.InsuranceInfoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceInfoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.InsuranceInfoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceInfoPayload>
        }
        findMany: {
          args: Prisma.InsuranceInfoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceInfoPayload>[]
        }
        create: {
          args: Prisma.InsuranceInfoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceInfoPayload>
        }
        createMany: {
          args: Prisma.InsuranceInfoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.InsuranceInfoCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceInfoPayload>[]
        }
        delete: {
          args: Prisma.InsuranceInfoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceInfoPayload>
        }
        update: {
          args: Prisma.InsuranceInfoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceInfoPayload>
        }
        deleteMany: {
          args: Prisma.InsuranceInfoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.InsuranceInfoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.InsuranceInfoUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceInfoPayload>[]
        }
        upsert: {
          args: Prisma.InsuranceInfoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$InsuranceInfoPayload>
        }
        aggregate: {
          args: Prisma.InsuranceInfoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateInsuranceInfo>
        }
        groupBy: {
          args: Prisma.InsuranceInfoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InsuranceInfoGroupByOutputType>[]
        }
        count: {
          args: Prisma.InsuranceInfoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.InsuranceInfoCountAggregateOutputType> | number
        }
      }
    }
    ExtraInfo: {
      payload: Prisma.$ExtraInfoPayload<ExtArgs>
      fields: Prisma.ExtraInfoFieldRefs
      operations: {
        findUnique: {
          args: Prisma.ExtraInfoFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExtraInfoPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.ExtraInfoFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExtraInfoPayload>
        }
        findFirst: {
          args: Prisma.ExtraInfoFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExtraInfoPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.ExtraInfoFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExtraInfoPayload>
        }
        findMany: {
          args: Prisma.ExtraInfoFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExtraInfoPayload>[]
        }
        create: {
          args: Prisma.ExtraInfoCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExtraInfoPayload>
        }
        createMany: {
          args: Prisma.ExtraInfoCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.ExtraInfoCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExtraInfoPayload>[]
        }
        delete: {
          args: Prisma.ExtraInfoDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExtraInfoPayload>
        }
        update: {
          args: Prisma.ExtraInfoUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExtraInfoPayload>
        }
        deleteMany: {
          args: Prisma.ExtraInfoDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.ExtraInfoUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.ExtraInfoUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExtraInfoPayload>[]
        }
        upsert: {
          args: Prisma.ExtraInfoUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$ExtraInfoPayload>
        }
        aggregate: {
          args: Prisma.ExtraInfoAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateExtraInfo>
        }
        groupBy: {
          args: Prisma.ExtraInfoGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExtraInfoGroupByOutputType>[]
        }
        count: {
          args: Prisma.ExtraInfoCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.ExtraInfoCountAggregateOutputType> | number
        }
      }
    }
    Ucar: {
      payload: Prisma.$UcarPayload<ExtArgs>
      fields: Prisma.UcarFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UcarFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UcarFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPayload>
        }
        findFirst: {
          args: Prisma.UcarFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UcarFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPayload>
        }
        findMany: {
          args: Prisma.UcarFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPayload>[]
        }
        create: {
          args: Prisma.UcarCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPayload>
        }
        createMany: {
          args: Prisma.UcarCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UcarCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPayload>[]
        }
        delete: {
          args: Prisma.UcarDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPayload>
        }
        update: {
          args: Prisma.UcarUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPayload>
        }
        deleteMany: {
          args: Prisma.UcarDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UcarUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UcarUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPayload>[]
        }
        upsert: {
          args: Prisma.UcarUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPayload>
        }
        aggregate: {
          args: Prisma.UcarAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUcar>
        }
        groupBy: {
          args: Prisma.UcarGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UcarGroupByOutputType>[]
        }
        count: {
          args: Prisma.UcarCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UcarCountAggregateOutputType> | number
        }
      }
    }
    Number98IssueHistory: {
      payload: Prisma.$Number98IssueHistoryPayload<ExtArgs>
      fields: Prisma.Number98IssueHistoryFieldRefs
      operations: {
        findUnique: {
          args: Prisma.Number98IssueHistoryFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98IssueHistoryPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.Number98IssueHistoryFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98IssueHistoryPayload>
        }
        findFirst: {
          args: Prisma.Number98IssueHistoryFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98IssueHistoryPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.Number98IssueHistoryFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98IssueHistoryPayload>
        }
        findMany: {
          args: Prisma.Number98IssueHistoryFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98IssueHistoryPayload>[]
        }
        create: {
          args: Prisma.Number98IssueHistoryCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98IssueHistoryPayload>
        }
        createMany: {
          args: Prisma.Number98IssueHistoryCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.Number98IssueHistoryCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98IssueHistoryPayload>[]
        }
        delete: {
          args: Prisma.Number98IssueHistoryDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98IssueHistoryPayload>
        }
        update: {
          args: Prisma.Number98IssueHistoryUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98IssueHistoryPayload>
        }
        deleteMany: {
          args: Prisma.Number98IssueHistoryDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.Number98IssueHistoryUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.Number98IssueHistoryUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98IssueHistoryPayload>[]
        }
        upsert: {
          args: Prisma.Number98IssueHistoryUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$Number98IssueHistoryPayload>
        }
        aggregate: {
          args: Prisma.Number98IssueHistoryAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateNumber98IssueHistory>
        }
        groupBy: {
          args: Prisma.Number98IssueHistoryGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Number98IssueHistoryGroupByOutputType>[]
        }
        count: {
          args: Prisma.Number98IssueHistoryCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.Number98IssueHistoryCountAggregateOutputType> | number
        }
      }
    }
    AppliedUcarGarageSlot: {
      payload: Prisma.$AppliedUcarGarageSlotPayload<ExtArgs>
      fields: Prisma.AppliedUcarGarageSlotFieldRefs
      operations: {
        findUnique: {
          args: Prisma.AppliedUcarGarageSlotFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppliedUcarGarageSlotPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.AppliedUcarGarageSlotFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppliedUcarGarageSlotPayload>
        }
        findFirst: {
          args: Prisma.AppliedUcarGarageSlotFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppliedUcarGarageSlotPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.AppliedUcarGarageSlotFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppliedUcarGarageSlotPayload>
        }
        findMany: {
          args: Prisma.AppliedUcarGarageSlotFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppliedUcarGarageSlotPayload>[]
        }
        create: {
          args: Prisma.AppliedUcarGarageSlotCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppliedUcarGarageSlotPayload>
        }
        createMany: {
          args: Prisma.AppliedUcarGarageSlotCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.AppliedUcarGarageSlotCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppliedUcarGarageSlotPayload>[]
        }
        delete: {
          args: Prisma.AppliedUcarGarageSlotDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppliedUcarGarageSlotPayload>
        }
        update: {
          args: Prisma.AppliedUcarGarageSlotUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppliedUcarGarageSlotPayload>
        }
        deleteMany: {
          args: Prisma.AppliedUcarGarageSlotDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.AppliedUcarGarageSlotUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.AppliedUcarGarageSlotUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppliedUcarGarageSlotPayload>[]
        }
        upsert: {
          args: Prisma.AppliedUcarGarageSlotUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$AppliedUcarGarageSlotPayload>
        }
        aggregate: {
          args: Prisma.AppliedUcarGarageSlotAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateAppliedUcarGarageSlot>
        }
        groupBy: {
          args: Prisma.AppliedUcarGarageSlotGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AppliedUcarGarageSlotGroupByOutputType>[]
        }
        count: {
          args: Prisma.AppliedUcarGarageSlotCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AppliedUcarGarageSlotCountAggregateOutputType> | number
        }
      }
    }
    UcarGarageSlotMaster: {
      payload: Prisma.$UcarGarageSlotMasterPayload<ExtArgs>
      fields: Prisma.UcarGarageSlotMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UcarGarageSlotMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageSlotMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UcarGarageSlotMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageSlotMasterPayload>
        }
        findFirst: {
          args: Prisma.UcarGarageSlotMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageSlotMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UcarGarageSlotMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageSlotMasterPayload>
        }
        findMany: {
          args: Prisma.UcarGarageSlotMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageSlotMasterPayload>[]
        }
        create: {
          args: Prisma.UcarGarageSlotMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageSlotMasterPayload>
        }
        createMany: {
          args: Prisma.UcarGarageSlotMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UcarGarageSlotMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageSlotMasterPayload>[]
        }
        delete: {
          args: Prisma.UcarGarageSlotMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageSlotMasterPayload>
        }
        update: {
          args: Prisma.UcarGarageSlotMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageSlotMasterPayload>
        }
        deleteMany: {
          args: Prisma.UcarGarageSlotMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UcarGarageSlotMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UcarGarageSlotMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageSlotMasterPayload>[]
        }
        upsert: {
          args: Prisma.UcarGarageSlotMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageSlotMasterPayload>
        }
        aggregate: {
          args: Prisma.UcarGarageSlotMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUcarGarageSlotMaster>
        }
        groupBy: {
          args: Prisma.UcarGarageSlotMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UcarGarageSlotMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.UcarGarageSlotMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UcarGarageSlotMasterCountAggregateOutputType> | number
        }
      }
    }
    UcarGarageLocationMaster: {
      payload: Prisma.$UcarGarageLocationMasterPayload<ExtArgs>
      fields: Prisma.UcarGarageLocationMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UcarGarageLocationMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageLocationMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UcarGarageLocationMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageLocationMasterPayload>
        }
        findFirst: {
          args: Prisma.UcarGarageLocationMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageLocationMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UcarGarageLocationMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageLocationMasterPayload>
        }
        findMany: {
          args: Prisma.UcarGarageLocationMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageLocationMasterPayload>[]
        }
        create: {
          args: Prisma.UcarGarageLocationMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageLocationMasterPayload>
        }
        createMany: {
          args: Prisma.UcarGarageLocationMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UcarGarageLocationMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageLocationMasterPayload>[]
        }
        delete: {
          args: Prisma.UcarGarageLocationMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageLocationMasterPayload>
        }
        update: {
          args: Prisma.UcarGarageLocationMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageLocationMasterPayload>
        }
        deleteMany: {
          args: Prisma.UcarGarageLocationMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UcarGarageLocationMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UcarGarageLocationMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageLocationMasterPayload>[]
        }
        upsert: {
          args: Prisma.UcarGarageLocationMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarGarageLocationMasterPayload>
        }
        aggregate: {
          args: Prisma.UcarGarageLocationMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUcarGarageLocationMaster>
        }
        groupBy: {
          args: Prisma.UcarGarageLocationMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UcarGarageLocationMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.UcarGarageLocationMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UcarGarageLocationMasterCountAggregateOutputType> | number
        }
      }
    }
    BankMaster: {
      payload: Prisma.$BankMasterPayload<ExtArgs>
      fields: Prisma.BankMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BankMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BankMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankMasterPayload>
        }
        findFirst: {
          args: Prisma.BankMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BankMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankMasterPayload>
        }
        findMany: {
          args: Prisma.BankMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankMasterPayload>[]
        }
        create: {
          args: Prisma.BankMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankMasterPayload>
        }
        createMany: {
          args: Prisma.BankMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BankMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankMasterPayload>[]
        }
        delete: {
          args: Prisma.BankMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankMasterPayload>
        }
        update: {
          args: Prisma.BankMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankMasterPayload>
        }
        deleteMany: {
          args: Prisma.BankMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BankMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BankMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankMasterPayload>[]
        }
        upsert: {
          args: Prisma.BankMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankMasterPayload>
        }
        aggregate: {
          args: Prisma.BankMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBankMaster>
        }
        groupBy: {
          args: Prisma.BankMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BankMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.BankMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BankMasterCountAggregateOutputType> | number
        }
      }
    }
    BankBranchMaster: {
      payload: Prisma.$BankBranchMasterPayload<ExtArgs>
      fields: Prisma.BankBranchMasterFieldRefs
      operations: {
        findUnique: {
          args: Prisma.BankBranchMasterFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankBranchMasterPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.BankBranchMasterFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankBranchMasterPayload>
        }
        findFirst: {
          args: Prisma.BankBranchMasterFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankBranchMasterPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.BankBranchMasterFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankBranchMasterPayload>
        }
        findMany: {
          args: Prisma.BankBranchMasterFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankBranchMasterPayload>[]
        }
        create: {
          args: Prisma.BankBranchMasterCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankBranchMasterPayload>
        }
        createMany: {
          args: Prisma.BankBranchMasterCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.BankBranchMasterCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankBranchMasterPayload>[]
        }
        delete: {
          args: Prisma.BankBranchMasterDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankBranchMasterPayload>
        }
        update: {
          args: Prisma.BankBranchMasterUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankBranchMasterPayload>
        }
        deleteMany: {
          args: Prisma.BankBranchMasterDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.BankBranchMasterUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.BankBranchMasterUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankBranchMasterPayload>[]
        }
        upsert: {
          args: Prisma.BankBranchMasterUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$BankBranchMasterPayload>
        }
        aggregate: {
          args: Prisma.BankBranchMasterAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateBankBranchMaster>
        }
        groupBy: {
          args: Prisma.BankBranchMasterGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BankBranchMasterGroupByOutputType>[]
        }
        count: {
          args: Prisma.BankBranchMasterCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.BankBranchMasterCountAggregateOutputType> | number
        }
      }
    }
    UcarProcess: {
      payload: Prisma.$UcarProcessPayload<ExtArgs>
      fields: Prisma.UcarProcessFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UcarProcessFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarProcessPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UcarProcessFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarProcessPayload>
        }
        findFirst: {
          args: Prisma.UcarProcessFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarProcessPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UcarProcessFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarProcessPayload>
        }
        findMany: {
          args: Prisma.UcarProcessFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarProcessPayload>[]
        }
        create: {
          args: Prisma.UcarProcessCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarProcessPayload>
        }
        createMany: {
          args: Prisma.UcarProcessCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UcarProcessCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarProcessPayload>[]
        }
        delete: {
          args: Prisma.UcarProcessDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarProcessPayload>
        }
        update: {
          args: Prisma.UcarProcessUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarProcessPayload>
        }
        deleteMany: {
          args: Prisma.UcarProcessDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UcarProcessUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UcarProcessUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarProcessPayload>[]
        }
        upsert: {
          args: Prisma.UcarProcessUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarProcessPayload>
        }
        aggregate: {
          args: Prisma.UcarProcessAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUcarProcess>
        }
        groupBy: {
          args: Prisma.UcarProcessGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UcarProcessGroupByOutputType>[]
        }
        count: {
          args: Prisma.UcarProcessCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UcarProcessCountAggregateOutputType> | number
        }
      }
    }
    UcarPaperWorkNotes: {
      payload: Prisma.$UcarPaperWorkNotesPayload<ExtArgs>
      fields: Prisma.UcarPaperWorkNotesFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UcarPaperWorkNotesFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPaperWorkNotesPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UcarPaperWorkNotesFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPaperWorkNotesPayload>
        }
        findFirst: {
          args: Prisma.UcarPaperWorkNotesFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPaperWorkNotesPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UcarPaperWorkNotesFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPaperWorkNotesPayload>
        }
        findMany: {
          args: Prisma.UcarPaperWorkNotesFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPaperWorkNotesPayload>[]
        }
        create: {
          args: Prisma.UcarPaperWorkNotesCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPaperWorkNotesPayload>
        }
        createMany: {
          args: Prisma.UcarPaperWorkNotesCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UcarPaperWorkNotesCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPaperWorkNotesPayload>[]
        }
        delete: {
          args: Prisma.UcarPaperWorkNotesDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPaperWorkNotesPayload>
        }
        update: {
          args: Prisma.UcarPaperWorkNotesUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPaperWorkNotesPayload>
        }
        deleteMany: {
          args: Prisma.UcarPaperWorkNotesDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UcarPaperWorkNotesUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UcarPaperWorkNotesUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPaperWorkNotesPayload>[]
        }
        upsert: {
          args: Prisma.UcarPaperWorkNotesUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarPaperWorkNotesPayload>
        }
        aggregate: {
          args: Prisma.UcarPaperWorkNotesAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUcarPaperWorkNotes>
        }
        groupBy: {
          args: Prisma.UcarPaperWorkNotesGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UcarPaperWorkNotesGroupByOutputType>[]
        }
        count: {
          args: Prisma.UcarPaperWorkNotesCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UcarPaperWorkNotesCountAggregateOutputType> | number
        }
      }
    }
    UcarRequest: {
      payload: Prisma.$UcarRequestPayload<ExtArgs>
      fields: Prisma.UcarRequestFieldRefs
      operations: {
        findUnique: {
          args: Prisma.UcarRequestFindUniqueArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarRequestPayload> | null
        }
        findUniqueOrThrow: {
          args: Prisma.UcarRequestFindUniqueOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarRequestPayload>
        }
        findFirst: {
          args: Prisma.UcarRequestFindFirstArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarRequestPayload> | null
        }
        findFirstOrThrow: {
          args: Prisma.UcarRequestFindFirstOrThrowArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarRequestPayload>
        }
        findMany: {
          args: Prisma.UcarRequestFindManyArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarRequestPayload>[]
        }
        create: {
          args: Prisma.UcarRequestCreateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarRequestPayload>
        }
        createMany: {
          args: Prisma.UcarRequestCreateManyArgs<ExtArgs>
          result: BatchPayload
        }
        createManyAndReturn: {
          args: Prisma.UcarRequestCreateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarRequestPayload>[]
        }
        delete: {
          args: Prisma.UcarRequestDeleteArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarRequestPayload>
        }
        update: {
          args: Prisma.UcarRequestUpdateArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarRequestPayload>
        }
        deleteMany: {
          args: Prisma.UcarRequestDeleteManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateMany: {
          args: Prisma.UcarRequestUpdateManyArgs<ExtArgs>
          result: BatchPayload
        }
        updateManyAndReturn: {
          args: Prisma.UcarRequestUpdateManyAndReturnArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarRequestPayload>[]
        }
        upsert: {
          args: Prisma.UcarRequestUpsertArgs<ExtArgs>
          result: runtime.Types.Utils.PayloadToResult<Prisma.$UcarRequestPayload>
        }
        aggregate: {
          args: Prisma.UcarRequestAggregateArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.AggregateUcarRequest>
        }
        groupBy: {
          args: Prisma.UcarRequestGroupByArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UcarRequestGroupByOutputType>[]
        }
        count: {
          args: Prisma.UcarRequestCountArgs<ExtArgs>
          result: runtime.Types.Utils.Optional<Prisma.UcarRequestCountAggregateOutputType> | number
        }
      }
    }
  }
} & {
  other: {
    payload: any
    operations: {
      $executeRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $executeRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
      $queryRaw: {
        args: [query: TemplateStringsArray | Sql, ...values: any[]],
        result: any
      }
      $queryRawUnsafe: {
        args: [query: string, ...values: any[]],
        result: any
      }
    }
  }
}

/**
 * Enums
 */

export const TransactionIsolationLevel = runtime.makeStrictEnum({
  ReadUncommitted: 'ReadUncommitted',
  ReadCommitted: 'ReadCommitted',
  RepeatableRead: 'RepeatableRead',
  Serializable: 'Serializable'
} as const)

export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


export const CarScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  processLastUpdatedAt: 'processLastUpdatedAt',
  active: 'active',
  sortOrder: 'sortOrder',
  bpNumber: 'bpNumber',
  orderedAt: 'orderedAt',
  orderCategory: 'orderCategory',
  estimate: 'estimate',
  orderStatusCategory: 'orderStatusCategory',
  customerName: 'customerName',
  carName: 'carName',
  plate: 'plate',
  frame: 'frame',
  katashiki: 'katashiki',
  managementCode: 'managementCode',
  initDate: 'initDate',
  currentEstimate: 'currentEstimate',
  scheduledAt: 'scheduledAt',
  insuranceType: 'insuranceType',
  insuranceCompany: 'insuranceCompany',
  agreedPrice: 'agreedPrice',
  userId: 'userId',
  crUserId: 'crUserId',
  storeId: 'storeId',
  damageNameMasterId: 'damageNameMasterId',
  orderNumber: 'orderNumber',
  crScheduledAt: 'crScheduledAt',
  engineerScheduledAt: 'engineerScheduledAt',
  representativeCarBpNumber: 'representativeCarBpNumber',
  favoredByUserIds: 'favoredByUserIds',
  prePermission: 'prePermission',
  preStart: 'preStart',
  carType: 'carType',
  advancePayment: 'advancePayment',
  complexKey: 'complexKey'
} as const

export type CarScalarFieldEnum = (typeof CarScalarFieldEnum)[keyof typeof CarScalarFieldEnum]


export const UserProcessConfirmationScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  userId: 'userId',
  date: 'date',
  checked: 'checked',
  updatedAt: 'updatedAt'
} as const

export type UserProcessConfirmationScalarFieldEnum = (typeof UserProcessConfirmationScalarFieldEnum)[keyof typeof UserProcessConfirmationScalarFieldEnum]


export const NotesScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  active: 'active',
  sortOrder: 'sortOrder',
  content: 'content',
  settled: 'settled',
  carId: 'carId',
  noteNameMasterId: 'noteNameMasterId',
  userId: 'userId',
  updatedAt: 'updatedAt'
} as const

export type NotesScalarFieldEnum = (typeof NotesScalarFieldEnum)[keyof typeof NotesScalarFieldEnum]


export const DamageNameMasterScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  active: 'active',
  sortOrder: 'sortOrder',
  name: 'name',
  type: 'type',
  color: 'color',
  carPerDay: 'carPerDay',
  updatedAt: 'updatedAt'
} as const

export type DamageNameMasterScalarFieldEnum = (typeof DamageNameMasterScalarFieldEnum)[keyof typeof DamageNameMasterScalarFieldEnum]


export const NoteNameMasterScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  active: 'active',
  sortOrder: 'sortOrder',
  name: 'name',
  type: 'type',
  color: 'color',
  updatedAt: 'updatedAt'
} as const

export type NoteNameMasterScalarFieldEnum = (typeof NoteNameMasterScalarFieldEnum)[keyof typeof NoteNameMasterScalarFieldEnum]


export const BpSummaryScalarFieldEnum = {
  id: 'id',
  code: 'code',
  createdAt: 'createdAt',
  active: 'active',
  sortOrder: 'sortOrder',
  date: 'date',
  key: 'key',
  label: 'label',
  count: 'count',
  storeId: 'storeId',
  updatedAt: 'updatedAt'
} as const

export type BpSummaryScalarFieldEnum = (typeof BpSummaryScalarFieldEnum)[keyof typeof BpSummaryScalarFieldEnum]


export const ProcessNameMasterScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  active: 'active',
  sortOrder: 'sortOrder',
  name: 'name',
  type: 'type',
  color: 'color',
  onEnginerProcess: 'onEnginerProcess',
  repetitionLimit: 'repetitionLimit',
  updatedAt: 'updatedAt'
} as const

export type ProcessNameMasterScalarFieldEnum = (typeof ProcessNameMasterScalarFieldEnum)[keyof typeof ProcessNameMasterScalarFieldEnum]


export const ProcessScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  date: 'date',
  active: 'active',
  sortOrder: 'sortOrder',
  time: 'time',
  processNameMasterId: 'processNameMasterId',
  carId: 'carId',
  userId: 'userId',
  storeId: 'storeId',
  note: 'note',
  name: 'name',
  type: 'type'
} as const

export type ProcessScalarFieldEnum = (typeof ProcessScalarFieldEnum)[keyof typeof ProcessScalarFieldEnum]


export const ReleaseNotesScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  rootPath: 'rootPath',
  title: 'title',
  msg: 'msg',
  imgUrl: 'imgUrl',
  confirmedUserIds: 'confirmedUserIds',
  updatedAt: 'updatedAt'
} as const

export type ReleaseNotesScalarFieldEnum = (typeof ReleaseNotesScalarFieldEnum)[keyof typeof ReleaseNotesScalarFieldEnum]


export const CrUserScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  active: 'active',
  sortOrder: 'sortOrder',
  carId: 'carId',
  userId: 'userId'
} as const

export type CrUserScalarFieldEnum = (typeof CrUserScalarFieldEnum)[keyof typeof CrUserScalarFieldEnum]


export const JuchuShitadoriDbScalarFieldEnum = {
  id: 'id',
  sortOrder: 'sortOrder',
  APPINDEX: 'APPINDEX',
  APPINDEX_FKEY: 'APPINDEX_FKEY',
  CD_KAISYA: 'CD_KAISYA',
  KB_SINCYU: 'KB_SINCYU',
  NO_CYUMON: 'NO_CYUMON',
  NO_CYUMONED: 'NO_CYUMONED',
  NO_SITARENB: 'NO_SITARENB',
  KB_SITASNSY: 'KB_SITASNSY',
  CD_NORIKUSI: 'CD_NORIKUSI',
  KB_NOSYASYU: 'KB_NOSYASYU',
  CD_NOGYOTAI: 'CD_NOGYOTAI',
  NO_NOSEIRI: 'NO_NOSEIRI',
  KB_RIKUSI: 'KB_RIKUSI',
  KB_MITRCHUB: 'KB_MITRCHUB',
  NO_SATEISYO: 'NO_SATEISYO',
  NO_SITERUIB: 'NO_SITERUIB',
  DD_SATEI: 'DD_SATEI',
  NO_SYARYOU: 'NO_SYARYOU',
  KI_SITADKAK: 'KI_SITADKAK',
  NU_JIBAIMIK: 'NU_JIBAIMIK',
  NU_ZEIRITU: 'NU_ZEIRITU',
  KB_SITASYHI: 'KB_SITASYHI',
  KI_SITASYHI: 'KI_SITASYHI',
  KI_SITATHU1: 'KI_SITATHU1',
  KI_SITATHU2: 'KI_SITATHU2',
  KI_SITATHU3: 'KI_SITATHU3',
  CD_SITADOSY: 'CD_SITADOSY',
  DD_SYKNMANR: 'DD_SYKNMANR',
  SU_SYNDOTOR: 'SU_SYNDOTOR',
  MJ_SITKATA: 'MJ_SITKATA',
  MJ_FURUKATA: 'MJ_FURUKATA',
  MJ_FURON: 'MJ_FURON',
  NO_SYADAIBA: 'NO_SYADAIBA',
  NU_SOUKOUKM: 'NU_SOUKOUKM',
  KJ_SIYOSYA: 'KJ_SIYOSYA',
  KJ_SYYUMAI: 'KJ_SYYUMAI',
  KB_ZANSEKSA: 'KB_ZANSEKSA',
  MJ_ZANSEKSA: 'MJ_ZANSEKSA',
  DD_KANSAIYO: 'DD_KANSAIYO',
  DD_KAIKESAI: 'DD_KAIKESAI',
  KI_SITAKESA: 'KI_SITAKESA',
  KJ_SITAMEMO: 'KJ_SITAMEMO',
  KB_JIDZMNOH: 'KB_JIDZMNOH',
  KB_YOTAKU: 'KB_YOTAKU',
  KI_AZRECYYO: 'KI_AZRECYYO',
  KI_SYRDST: 'KI_SYRDST',
  KI_AIRBAGRU: 'KI_AIRBAGRU',
  KI_FURONR: 'KI_FURONR',
  KI_JOHOKR: 'KI_JOHOKR',
  KI_SIKNKNR: 'KI_SIKNKNR',
  NO_RECYCLEK: 'NO_RECYCLEK',
  KB_SIYZJDHT: 'KB_SIYZJDHT',
  KJ_SAISSYYU: 'KJ_SAISSYYU',
  KI_SIYZJDHI: 'KI_SIYZJDHI',
  KI_STJIZESO: 'KI_STJIZESO',
  MJ_SIYZSHIF: 'MJ_SIYZSHIF',
  MJ_HIKIZUMF: 'MJ_HIKIZUMF',
  DD_SITATORI: 'DD_SITATORI',
  NO_SITAJOJO: 'NO_SITAJOJO',
  NO_KYUSATEI: 'NO_KYUSATEI',
  DT_SAISINUP: 'DT_SAISINUP',
  MJ_SASINTAN: 'MJ_SASINTAN',
  N_JUCYU: 'N_JUCYU',
  U_JUCYU: 'U_JUCYU',
  KJ_SYAMEI: 'KJ_SYAMEI'
} as const

export type JuchuShitadoriDbScalarFieldEnum = (typeof JuchuShitadoriDbScalarFieldEnum)[keyof typeof JuchuShitadoriDbScalarFieldEnum]


export const OldCars_BaseScalarFieldEnum = {
  id: 'id',
  sortOrder: 'sortOrder',
  APPINDEX: 'APPINDEX',
  CD_21SYAMEI: 'CD_21SYAMEI',
  MJ_SYAMEI: 'MJ_SYAMEI',
  CD_HANSTAFF: 'CD_HANSTAFF',
  CD_HANTENPO: 'CD_HANTENPO',
  NO_SIRETYUM: 'NO_SIRETYUM',
  MJ_SIRENORI: 'MJ_SIRENORI',
  KB_SIRETOSY: 'KB_SIRETOSY',
  CD_SIRETOGY: 'CD_SIRETOGY',
  NO_SIRETOSE: 'NO_SIRETOSE',
  NO_HANJTRIK: 'NO_HANJTRIK',
  KB_HANTOSY: 'KB_HANTOSY',
  CD_HANTOGY: 'CD_HANTOGY',
  NO_HANTOSE: 'NO_HANTOSE',
  CD_SITASTAF: 'CD_SITASTAF',
  DD_SIIRE: 'DD_SIIRE',
  DD_SIREBD: 'DD_SIREBD',
  SU_SYODOTOR: 'SU_SYODOTOR',
  NO_FRAME: 'NO_FRAME',
  KI_SIIREKA: 'KI_SIIREKA',
  KI_HANKAKA: 'KI_HANKAKA',
  KB_SIIRE: 'KB_SIIRE',
  KB_SIHARAI: 'KB_SIHARAI',
  KB_URIAGE: 'KB_URIAGE',
  NO_CYUMON: 'NO_CYUMON',
  NO_CYUMONED: 'NO_CYUMONED',
  NO_SYARYOU: 'NO_SYARYOU',
  NO_SYADAIBA: 'NO_SYADAIBA',
  DT_SAISINUP: 'DT_SAISINUP',
  MJ_KATASIKI: 'MJ_KATASIKI',
  NU_SOUKOUKM: 'NU_SOUKOUKM',
  CD_SIRETENP: 'CD_SIRETENP',
  KJ_SIRESAKI: 'KJ_SIRESAKI',
  KB_UC1JTORO: 'KB_UC1JTORO',
  DD_URIAGE: 'DD_URIAGE',
  DD_1JTOROKU: 'DD_1JTOROKU',
  DD_2JTOROKU: 'DD_2JTOROKU',
  DD_SYKNMANR: 'DD_SYKNMANR',
  DD_SITASYUK: 'DD_SITASYUK',
  DD_NOSYA: 'DD_NOSYA',
  MJ_SITADOTE: 'MJ_SITADOTE'
} as const

export type OldCars_BaseScalarFieldEnum = (typeof OldCars_BaseScalarFieldEnum)[keyof typeof OldCars_BaseScalarFieldEnum]


export const Number98ScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  active: 'active',
  sortOrder: 'sortOrder',
  number: 'number',
  sortNumber: 'sortNumber',
  occupied: 'occupied'
} as const

export type Number98ScalarFieldEnum = (typeof Number98ScalarFieldEnum)[keyof typeof Number98ScalarFieldEnum]


export const ZAIKO_BaseScalarFieldEnum = {
  id: 'id',
  sortOrder: 'sortOrder',
  APPINDEX: 'APPINDEX',
  APPINDEX_FKEY: 'APPINDEX_FKEY',
  NO_SYARYOU: 'NO_SYARYOU',
  KB_SIIRE: 'KB_SIIRE',
  DD_KEIRIKEI: 'DD_KEIRIKEI',
  NO_SIRETYUM: 'NO_SIRETYUM',
  MJ_SIRENORI: 'MJ_SIRENORI',
  KB_SIRETOSY: 'KB_SIRETOSY',
  CD_SIRETOGY: 'CD_SIRETOGY',
  NO_SIRETOSE: 'NO_SIRETOSE',
  MJ_SIRESAKI: 'MJ_SIRESAKI',
  CD_SITADOTE: 'CD_SITADOTE',
  CD_SITASTAF: 'CD_SITASTAF',
  CD_SIRETENP: 'CD_SIRETENP',
  MJ_FURUSYAM: 'MJ_FURUSYAM',
  NO_KATASIKI: 'NO_KATASIKI',
  NO_FRAME: 'NO_FRAME',
  CD_TENJTENP: 'CD_TENJTENP',
  KI_HNBSIJIK: 'KI_HNBSIJIK',
  KI_TENTOHYJ: 'KI_TENTOHYJ',
  CD_ZAIKSYYS: 'CD_ZAIKSYYS',
  KB_SYASYHAN: 'KB_SYASYHAN',
  NO_SYADAIBA: 'NO_SYADAIBA',
  KI_SIIREKA: 'KI_SIIREKA',
  KN_KEI: 'KN_KEI',
  MJ_ZAIKOST: 'MJ_ZAIKOST',
  CD_ZAIKOTEN: 'CD_ZAIKOTEN',
  NO_CYUMON: 'NO_CYUMON',
  KB_URIAGE: 'KB_URIAGE',
  CD_HANSTAFF: 'CD_HANSTAFF',
  MJ_21SYASYS: 'MJ_21SYASYS',
  MJ_SIJYOKBM: 'MJ_SIJYOKBM',
  DT_SAISINUP: 'DT_SAISINUP',
  DD_SIIRE: 'DD_SIIRE'
} as const

export type ZAIKO_BaseScalarFieldEnum = (typeof ZAIKO_BaseScalarFieldEnum)[keyof typeof ZAIKO_BaseScalarFieldEnum]


export const UpassFamilyTreeScalarFieldEnum = {
  id: 'id',
  sateiID: 'sateiID',
  rootSateiID: 'rootSateiID',
  sateiDate: 'sateiDate'
} as const

export type UpassFamilyTreeScalarFieldEnum = (typeof UpassFamilyTreeScalarFieldEnum)[keyof typeof UpassFamilyTreeScalarFieldEnum]


export const UPASSScalarFieldEnum = {
  id: 'id',
  dataSource: 'dataSource',
  shitadoriRelationAssessmentNumber: 'shitadoriRelationAssessmentNumber',
  sortOrder: 'sortOrder',
  sateiID: 'sateiID',
  dealerName: 'dealerName',
  dealerCode: 'dealerCode',
  assessmentMode: 'assessmentMode',
  assessmentMode2: 'assessmentMode2',
  status: 'status',
  valuationType: 'valuationType',
  valuationNumber: 'valuationNumber',
  palAssessmentNumber: 'palAssessmentNumber',
  landAffairsName: 'landAffairsName',
  registrationClassNumber: 'registrationClassNumber',
  registrationKana: 'registrationKana',
  registrationSerialNumber: 'registrationSerialNumber',
  registrationDate: 'registrationDate',
  firstRegistrationYear: 'firstRegistrationYear',
  modelYear: 'modelYear',
  modelYearType: 'modelYearType',
  chassisNumber: 'chassisNumber',
  frameNumber: 'frameNumber',
  brandName: 'brandName',
  modelName: 'modelName',
  ai21ModelCode: 'ai21ModelCode',
  grade: 'grade',
  type: 'type',
  commonType: 'commonType',
  engineType: 'engineType',
  vehicleHistory: 'vehicleHistory',
  capacityMin: 'capacityMin',
  capacityMax: 'capacityMax',
  maxLoad: 'maxLoad',
  weight: 'weight',
  grossWeight: 'grossWeight',
  length: 'length',
  width: 'width',
  height: 'height',
  displacement: 'displacement',
  fuelName: 'fuelName',
  typeDesignationNumber: 'typeDesignationNumber',
  categoryNumber: 'categoryNumber',
  ownerName: 'ownerName',
  userName: 'userName',
  useOwnershipSameFlag: 'useOwnershipSameFlag',
  ai21CustomerCode: 'ai21CustomerCode',
  customerName: 'customerName',
  customerKanaSurname: 'customerKanaSurname',
  customerKanaName: 'customerKanaName',
  inspectionExpiryDate: 'inspectionExpiryDate',
  odometerDisplayValue: 'odometerDisplayValue',
  newCarWarranty: 'newCarWarranty',
  maintenanceManual: 'maintenanceManual',
  instructionManual: 'instructionManual',
  periodicInspectionRecord: 'periodicInspectionRecord',
  unexpiredLiabilityAmount: 'unexpiredLiabilityAmount',
  liabilityInsuranceStartDate: 'liabilityInsuranceStartDate',
  liabilityInsuranceEndDate: 'liabilityInsuranceEndDate',
  unexpiredTaxAmount: 'unexpiredTaxAmount',
  recyclingCertificate: 'recyclingCertificate',
  recyclingCertificateNumber: 'recyclingCertificateNumber',
  shredderDustFee: 'shredderDustFee',
  airbagFee: 'airbagFee',
  freonFee: 'freonFee',
  infoManagementFee: 'infoManagementFee',
  recyclingDeposit: 'recyclingDeposit',
  importCategory: 'importCategory',
  bodyType: 'bodyType',
  driveType: 'driveType',
  transmissionType: 'transmissionType',
  steering: 'steering',
  doorType: 'doorType',
  coldWeatherSpec: 'coldWeatherSpec',
  exteriorColor: 'exteriorColor',
  colorCode: 'colorCode',
  colorName: 'colorName',
  interiorColor: 'interiorColor',
  repairHistory: 'repairHistory',
  mileageKm: 'mileageKm',
  meterReplacement: 'meterReplacement',
  totalMileage: 'totalMileage',
  importVehicle: 'importVehicle',
  modelYearDetail: 'modelYearDetail',
  sunroofMoonroof: 'sunroofMoonroof',
  frontAc: 'frontAc',
  rearAc: 'rearAc',
  powerSteering: 'powerSteering',
  powerWindow: 'powerWindow',
  abs: 'abs',
  electricSlideDoor: 'electricSlideDoor',
  seatMaterial: 'seatMaterial',
  airbagFeeDetail: 'airbagFeeDetail',
  carNaviDa: 'carNaviDa',
  tv: 'tv',
  rearMonitor: 'rearMonitor',
  backMonitor: 'backMonitor',
  cd: 'cd',
  dvd: 'dvd',
  mediaPlayer: 'mediaPlayer',
  rearEntertainment: 'rearEntertainment',
  markLevinson: 'markLevinson',
  aeroSpoiler: 'aeroSpoiler',
  aluminumWheel: 'aluminumWheel',
  cruiseControl: 'cruiseControl',
  skidControl: 'skidControl',
  immobilizer: 'immobilizer',
  powerSeat: 'powerSeat',
  fullFlat: 'fullFlat',
  benchSeat: 'benchSeat',
  threeRowSeat: 'threeRowSeat',
  walkThrough: 'walkThrough',
  lowDown: 'lowDown',
  headlamp: 'headlamp',
  keylessEntry: 'keylessEntry',
  remoteStarter: 'remoteStarter',
  etc: 'etc',
  oneOwner: 'oneOwner',
  testDrive: 'testDrive',
  activeStabilizer: 'activeStabilizer',
  collisionAvoidance: 'collisionAvoidance',
  pedalMisstep: 'pedalMisstep',
  laneDeparture: 'laneDeparture',
  advancedLight: 'advancedLight',
  blindSpotMonitor: 'blindSpotMonitor',
  panoramicViewMonitor: 'panoramicViewMonitor',
  driveRecorder: 'driveRecorder',
  idling: 'idling',
  outlet: 'outlet',
  additionalEquipment1: 'additionalEquipment1',
  additionalEquipment2: 'additionalEquipment2',
  additionalEquipment3: 'additionalEquipment3',
  additionalEquipment4: 'additionalEquipment4',
  additionalEquipment5: 'additionalEquipment5',
  evFlag: 'evFlag',
  reFlag: 'reFlag',
  ac: 'ac',
  navi: 'navi',
  tv2: 'tv2',
  leather: 'leather',
  sr: 'sr',
  aluminum: 'aluminum',
  assessmentdatetime: 'assessmentdatetime',
  tradeInPurchaseCategory: 'tradeInPurchaseCategory',
  pickupScheduledDate: 'pickupScheduledDate',
  requestingName: 'requestingName',
  requestingCode: 'requestingCode',
  assessmentname: 'assessmentname',
  assessmentcode: 'assessmentcode',
  assessmentStaffName: 'assessmentStaffName',
  assessmentStaffCode: 'assessmentStaffCode',
  salesname: 'salesname',
  salescode: 'salescode',
  salesStaffName: 'salesStaffName',
  salesStaffCode: 'salesStaffCode',
  plannedPurchaseVehicle: 'plannedPurchaseVehicle',
  residualValueInstallmentFinalDate: 'residualValueInstallmentFinalDate',
  residualValueInstallmentFinalAmount: 'residualValueInstallmentFinalAmount',
  urgencyStatus: 'urgencyStatus',
  valuationContactNotes: 'valuationContactNotes',
  valuationRequestDatetime: 'valuationRequestDatetime',
  comprehensiveEvaluationScore: 'comprehensiveEvaluationScore',
  assessmentAdjustmentPointsTotal: 'assessmentAdjustmentPointsTotal',
  newCarPriceExcludingTax: 'newCarPriceExcludingTax',
  assessmentPrice: 'assessmentPrice',
  adjustmentAmountTotal: 'adjustmentAmountTotal',
  adjustmentAmount1: 'adjustmentAmount1',
  adjustmentAmount1Notes: 'adjustmentAmount1Notes',
  adjustmentAmount2: 'adjustmentAmount2',
  adjustmentAmount2Notes: 'adjustmentAmount2Notes',
  adjustmentAmount3: 'adjustmentAmount3',
  adjustmentAmount3Notes: 'adjustmentAmount3Notes',
  adjustmentAmount4: 'adjustmentAmount4',
  adjustmentAmount5: 'adjustmentAmount5',
  approvedPrice: 'approvedPrice',
  assessmentResponsePrice: 'assessmentResponsePrice',
  inventoryAssessmentResponsePrice: 'inventoryAssessmentResponsePrice',
  assessmentError: 'assessmentError',
  valuationNotesMemo: 'valuationNotesMemo',
  salesPriceMemo: 'salesPriceMemo',
  salesStaffContactNotes: 'salesStaffContactNotes',
  valuationName: 'valuationName',
  valuationcode: 'valuationcode',
  valuationStoreName: 'valuationStoreName',
  valuationEmployeeCode: 'valuationEmployeeCode',
  inspectionname: 'inspectionname',
  inspectioncode: 'inspectioncode',
  pricingStoreName: 'pricingStoreName',
  pricecode: 'pricecode',
  inspectioName: 'inspectioName',
  inspectionNameCode: 'inspectionNameCode',
  pricingPersonName: 'pricingPersonName',
  pricingPersonCode: 'pricingPersonCode',
  valuationResponsedatetime: 'valuationResponsedatetime',
  valuationStarttime: 'valuationStarttime',
  valuationEndtime: 'valuationEndtime',
  valuationRequiredtime: 'valuationRequiredtime',
  priceConfirmationdatetime: 'priceConfirmationdatetime',
  inventoryAssessmentConfirmationdate: 'inventoryAssessmentConfirmationdate',
  previousValuationnumber: 'previousValuationnumber',
  previousAssessmentnumber: 'previousAssessmentnumber',
  cpoCategory: 'cpoCategory'
} as const

export type UPASSScalarFieldEnum = (typeof UPASSScalarFieldEnum)[keyof typeof UPASSScalarFieldEnum]


export const QR_ProsessScalarFieldEnum = {
  id: 'id',
  sortOrder: 'sortOrder',
  sateiId: 'sateiId',
  Sorting_results: 'Sorting_results',
  datetime_0: 'datetime_0',
  email_0: 'email_0',
  store_0: 'store_0',
  runnable_0: 'runnable_0',
  remarks_0: 'remarks_0',
  shitadoriKubun_0: 'shitadoriKubun_0',
  orderNumber_0: 'orderNumber_0',
  datetime_1: 'datetime_1',
  datetime_2: 'datetime_2',
  datetime_3: 'datetime_3',
  datetime_4: 'datetime_4',
  datetime_6: 'datetime_6',
  datetime_7: 'datetime_7',
  datetime_8: 'datetime_8',
  datetime_9: 'datetime_9',
  datetime_11: 'datetime_11',
  datetime_12: 'datetime_12',
  datetime_13: 'datetime_13',
  datetime_14: 'datetime_14',
  max_update: 'max_update'
} as const

export type QR_ProsessScalarFieldEnum = (typeof QR_ProsessScalarFieldEnum)[keyof typeof QR_ProsessScalarFieldEnum]


export const DeliverScheduleScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  date: 'date',
  carIds: 'carIds',
  updatedAt: 'updatedAt'
} as const

export type DeliverScheduleScalarFieldEnum = (typeof DeliverScheduleScalarFieldEnum)[keyof typeof DeliverScheduleScalarFieldEnum]


export const AreaScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  name: 'name',
  color: 'color',
  updatedAt: 'updatedAt'
} as const

export type AreaScalarFieldEnum = (typeof AreaScalarFieldEnum)[keyof typeof AreaScalarFieldEnum]


export const LoadingVehicleScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  deliverScheduleId: 'deliverScheduleId',
  areaId: 'areaId',
  pickedCarIds: 'pickedCarIds',
  slot: 'slot',
  updatedAt: 'updatedAt'
} as const

export type LoadingVehicleScalarFieldEnum = (typeof LoadingVehicleScalarFieldEnum)[keyof typeof LoadingVehicleScalarFieldEnum]


export const SlotScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  carId: 'carId',
  newCarId: 'newCarId',
  loadingVehicleId: 'loadingVehicleId',
  updatedAt: 'updatedAt'
} as const

export type SlotScalarFieldEnum = (typeof SlotScalarFieldEnum)[keyof typeof SlotScalarFieldEnum]


export const NewCarScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  storeId: 'storeId',
  updatedAt: 'updatedAt',
  APPINDEX: 'APPINDEX',
  CD_HANSTAFF: 'CD_HANSTAFF',
  CD_NCSYAMEI: 'CD_NCSYAMEI',
  CD_TENPO: 'CD_TENPO',
  DD_CENTTYAB: 'DD_CENTTYAB',
  DD_CENTYOB: 'DD_CENTYOB',
  DD_FR: 'DD_FR',
  DD_HAISKIBO: 'DD_HAISKIBO',
  DD_HAISOU: 'DD_HAISOU',
  DD_HAISOYOT: 'DD_HAISOYOT',
  DD_HONBSYOK: 'DD_HONBSYOK',
  DD_JUCYU: 'DD_JUCYU',
  DD_JUCYUKE: 'DD_JUCYUKE',
  DD_KIBONOKI: 'DD_KIBONOKI',
  DD_MAKERSYU: 'DD_MAKERSYU',
  DD_NOSYA: 'DD_NOSYA',
  DD_SYOUNIN1: 'DD_SYOUNIN1',
  DD_SYOUNIN2: 'DD_SYOUNIN2',
  DD_SYOUNIN3: 'DD_SYOUNIN3',
  DD_TENPSYOK: 'DD_TENPSYOK',
  DD_TOROKIBO: 'DD_TOROKIBO',
  DD_TOTYAKUY: 'DD_TOTYAKUY',
  DD_TOUROKU: 'DD_TOUROKU',
  DD_URIKZUMI: 'DD_URIKZUMI',
  KJ_KAINMEI1: 'KJ_KAINMEI1',
  KJ_KURUMAME: 'KJ_KURUMAME',
  KJ_MEIGIME1: 'KJ_MEIGIME1',
  MJ_HANTENKT: 'MJ_HANTENKT',
  NO_CYUMON: 'NO_CYUMON',
  NO_FRAME: 'NO_FRAME',
  m0Status: 'm0Status',
  m0_deadline_nousya: 'm0_deadline_nousya',
  m0_remarks: 'm0_remarks',
  m1Status: 'm1Status',
  m1_deadline_money: 'm1_deadline_money',
  m1_deadline_paper: 'm1_deadline_paper',
  m1_remarks: 'm1_remarks',
  m2Status: 'm2Status',
  m2_date: 'm2_date',
  m2_remarks: 'm2_remarks',
  userId: 'userId',
  m1Alert: 'm1Alert',
  m2Alert: 'm2Alert',
  lastApprovedDesiredTorokuDate: 'lastApprovedDesiredTorokuDate',
  lastApprovedDesiredTorokuDate__pending: 'lastApprovedDesiredTorokuDate__pending',
  m2_check1: 'm2_check1',
  m2_check2: 'm2_check2',
  m1_toroku_prediction: 'm1_toroku_prediction',
  initial_m0_deadline_nousya: 'initial_m0_deadline_nousya',
  initial_m1_deadline_money: 'initial_m1_deadline_money',
  initial_m1_deadline_paper: 'initial_m1_deadline_paper',
  initial_m1_toroku_prediction: 'initial_m1_toroku_prediction',
  DD_KARINOKI: 'DD_KARINOKI',
  DD_SAGTYYO: 'DD_SAGTYYO',
  KB_OSSSIN: 'KB_OSSSIN',
  MJ_OSSTSNST: 'MJ_OSSTSNST',
  KI_BETSIHAK: 'KI_BETSIHAK',
  KI_MAEUNYUK: 'KI_MAEUNYUK',
  KI_NYURUIKE: 'KI_NYURUIKE',
  KI_SHRIGK: 'KI_SHRIGK',
  KI_SITANYKG: 'KI_SITANYKG',
  crOperationRemarks: 'crOperationRemarks',
  haisou_tooEarly: 'haisou_tooEarly',
  torokuApplicationRequired: 'torokuApplicationRequired',
  DD_CENTSYUB: 'DD_CENTSYUB',
  DD_GENSYNYK: 'DD_GENSYNYK',
  KI_SITADORI: 'KI_SITADORI',
  KI_SITZAN: 'KI_SITZAN',
  DD_TORIKESI: 'DD_TORIKESI',
  DD_MAX_UPDATE: 'DD_MAX_UPDATE',
  earliestHaisouDate: 'earliestHaisouDate',
  DD_LATEST_HAISOU: 'DD_LATEST_HAISOU',
  DD_HAISYYO: 'DD_HAISYYO',
  DD_KANSEI: 'DD_KANSEI',
  DD_KRHURI: 'DD_KRHURI',
  KB_DAIHYNAI: 'KB_DAIHYNAI',
  TM_TOTUTMKE: 'TM_TOTUTMKE',
  CUSTOM_DD_SEISANYOTEI: 'CUSTOM_DD_SEISANYOTEI',
  CUSTOM_FR_DATE: 'CUSTOM_FR_DATE',
  CUSTOM_FR_KARI_NOTATION: 'CUSTOM_FR_KARI_NOTATION',
  CUSTOM_FR_NOTATION_TYPE: 'CUSTOM_FR_NOTATION_TYPE',
  CUSTOM_FR_PREFIX: 'CUSTOM_FR_PREFIX',
  CUSTOM_FR_SUFFIX: 'CUSTOM_FR_SUFFIX',
  CUSTOM_KB_GYOCYOK: 'CUSTOM_KB_GYOCYOK',
  CUSTOM_KB_SEIBETU: 'CUSTOM_KB_SEIBETU',
  CUSTOM_SEISANYOTEI: 'CUSTOM_SEISANYOTEI',
  CUSTOM_ZAIKO_KB_NOTATION: 'CUSTOM_ZAIKO_KB_NOTATION',
  CUSTOM_paymentCheck: 'CUSTOM_paymentCheck',
  CUSTOM_paymentCheckCustomerType: 'CUSTOM_paymentCheckCustomerType',
  CUSTOM_NET_SHITADORI_PRICE: 'CUSTOM_NET_SHITADORI_PRICE',
  KB_ZAIKOJYO: 'KB_ZAIKOJYO',
  isDaikoNosya: 'isDaikoNosya',
  sateiNyukobiAlert: 'sateiNyukobiAlert',
  shitadoriAlertCount: 'shitadoriAlertCount',
  ossSpreadsheetUrl: 'ossSpreadsheetUrl',
  transferType: 'transferType',
  orderSwitchingHisotoryId: 'orderSwitchingHisotoryId'
} as const

export type NewCarScalarFieldEnum = (typeof NewCarScalarFieldEnum)[keyof typeof NewCarScalarFieldEnum]


export const OrderSwitchingHisotoryScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  userId: 'userId'
} as const

export type OrderSwitchingHisotoryScalarFieldEnum = (typeof OrderSwitchingHisotoryScalarFieldEnum)[keyof typeof OrderSwitchingHisotoryScalarFieldEnum]


export const DesiredTorokuDateScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  date: 'date',
  remarks: 'remarks',
  newCarId: 'newCarId',
  status: 'status',
  torokuType: 'torokuType'
} as const

export type DesiredTorokuDateScalarFieldEnum = (typeof DesiredTorokuDateScalarFieldEnum)[keyof typeof DesiredTorokuDateScalarFieldEnum]


export const NewCarLeadTimeScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  key: 'key',
  value: 'value',
  newCarId: 'newCarId'
} as const

export type NewCarLeadTimeScalarFieldEnum = (typeof NewCarLeadTimeScalarFieldEnum)[keyof typeof NewCarLeadTimeScalarFieldEnum]


export const CrInspectionHistoryScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  newCarId: 'newCarId',
  userId: 'userId',
  status: 'status',
  date: 'date'
} as const

export type CrInspectionHistoryScalarFieldEnum = (typeof CrInspectionHistoryScalarFieldEnum)[keyof typeof CrInspectionHistoryScalarFieldEnum]


export const SeisanYoteiHistoryScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  key: 'key',
  newCarId: 'newCarId',
  from: 'from',
  to: 'to',
  fromDate: 'fromDate',
  toDate: 'toDate',
  issuedAt: 'issuedAt',
  notifyedAt: 'notifyedAt'
} as const

export type SeisanYoteiHistoryScalarFieldEnum = (typeof SeisanYoteiHistoryScalarFieldEnum)[keyof typeof SeisanYoteiHistoryScalarFieldEnum]


export const UserProgressAggregationTableScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  date: 'date',
  timing: 'timing',
  label: 'label',
  count: 'count',
  storeId: 'storeId',
  userId: 'userId'
} as const

export type UserProgressAggregationTableScalarFieldEnum = (typeof UserProgressAggregationTableScalarFieldEnum)[keyof typeof UserProgressAggregationTableScalarFieldEnum]


export const ProgressAggregationTableScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  date: 'date',
  storeId: 'storeId'
} as const

export type ProgressAggregationTableScalarFieldEnum = (typeof ProgressAggregationTableScalarFieldEnum)[keyof typeof ProgressAggregationTableScalarFieldEnum]


export const ProgressAggregationTableRecordScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  timing: 'timing',
  label: 'label',
  count: 'count',
  progressAggregationTableId: 'progressAggregationTableId'
} as const

export type ProgressAggregationTableRecordScalarFieldEnum = (typeof ProgressAggregationTableRecordScalarFieldEnum)[keyof typeof ProgressAggregationTableRecordScalarFieldEnum]


export const FuriateStatusOnApprovementScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  newCarId: 'newCarId',
  DD_FR: 'DD_FR'
} as const

export type FuriateStatusOnApprovementScalarFieldEnum = (typeof FuriateStatusOnApprovementScalarFieldEnum)[keyof typeof FuriateStatusOnApprovementScalarFieldEnum]


export const CarTransferHistoryScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  location: 'location',
  transferredAt: 'transferredAt',
  transferConfirmedOnAi21: 'transferConfirmedOnAi21',
  recoveredAt: 'recoveredAt',
  recoveredConfirmedOnAi21: 'recoveredConfirmedOnAi21',
  remarks: 'remarks',
  newCarId: 'newCarId'
} as const

export type CarTransferHistoryScalarFieldEnum = (typeof CarTransferHistoryScalarFieldEnum)[keyof typeof CarTransferHistoryScalarFieldEnum]


export const TenpoTsuikoShinseiHeaderScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  date: 'date',
  newCarId: 'newCarId',
  approvalOrder: 'approvalOrder',
  active: 'active'
} as const

export type TenpoTsuikoShinseiHeaderScalarFieldEnum = (typeof TenpoTsuikoShinseiHeaderScalarFieldEnum)[keyof typeof TenpoTsuikoShinseiHeaderScalarFieldEnum]


export const TenpoTsuikoShinseiDetailScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  userId: 'userId',
  status: 'status',
  comment: 'comment',
  approvalOrder: 'approvalOrder',
  tenpoTsuikoShinseiHeaderId: 'tenpoTsuikoShinseiHeaderId',
  processedAt: 'processedAt'
} as const

export type TenpoTsuikoShinseiDetailScalarFieldEnum = (typeof TenpoTsuikoShinseiDetailScalarFieldEnum)[keyof typeof TenpoTsuikoShinseiDetailScalarFieldEnum]


export const TenpoTsuikoDataScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  APPINDEX: 'APPINDEX',
  APPINDEX_FKEY: 'APPINDEX_FKEY',
  CD_TUIKO: 'CD_TUIKO',
  MJ_TUIKOM: 'MJ_TUIKOM',
  KI_TUIKOKIN: 'KI_TUIKOKIN',
  CD_TENPO: 'CD_TENPO',
  CD_HANSTAFF: 'CD_HANSTAFF',
  KJ_KURUMAME: 'KJ_KURUMAME',
  NO_CYUMON: 'NO_CYUMON',
  KJ_KAINMEI1: 'KJ_KAINMEI1',
  processed: 'processed',
  processedAt: 'processedAt'
} as const

export type TenpoTsuikoDataScalarFieldEnum = (typeof TenpoTsuikoDataScalarFieldEnum)[keyof typeof TenpoTsuikoDataScalarFieldEnum]


export const StoreScalarFieldEnum = {
  id: 'id',
  code: 'code',
  createdAt: 'createdAt',
  active: 'active',
  sortOrder: 'sortOrder',
  name: 'name',
  areaId: 'areaId',
  updatedAt: 'updatedAt',
  tel: 'tel',
  fax: 'fax',
  address: 'address'
} as const

export type StoreScalarFieldEnum = (typeof StoreScalarFieldEnum)[keyof typeof StoreScalarFieldEnum]


export const UserScalarFieldEnum = {
  id: 'id',
  code: 'code',
  createdAt: 'createdAt',
  active: 'active',
  sortOrder: 'sortOrder',
  name: 'name',
  kana: 'kana',
  email: 'email',
  password: 'password',
  type: 'type',
  role: 'role',
  tempResetCode: 'tempResetCode',
  tempResetCodeExpired: 'tempResetCodeExpired',
  storeId: 'storeId',
  schoolId: 'schoolId',
  rentaStoreId: 'rentaStoreId',
  type2: 'type2',
  shopId: 'shopId',
  membershipName: 'membershipName',
  damageNameMasterId: 'damageNameMasterId',
  color: 'color',
  tell: 'tell',
  app: 'app',
  updatedAt: 'updatedAt',
  apps: 'apps',
  loginCheck: 'loginCheck'
} as const

export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


export const GoogleAccessTokenScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  email: 'email',
  tokenJSON: 'tokenJSON',
  expiry_date: 'expiry_date'
} as const

export type GoogleAccessTokenScalarFieldEnum = (typeof GoogleAccessTokenScalarFieldEnum)[keyof typeof GoogleAccessTokenScalarFieldEnum]


export const RoleMasterScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  name: 'name',
  description: 'description',
  color: 'color',
  apps: 'apps'
} as const

export type RoleMasterScalarFieldEnum = (typeof RoleMasterScalarFieldEnum)[keyof typeof RoleMasterScalarFieldEnum]


export const UserRoleScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  userId: 'userId',
  roleMasterId: 'roleMasterId'
} as const

export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


export const CalendarScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  sortOrder: 'sortOrder',
  date: 'date',
  cr: 'cr',
  sharyobu: 'sharyobu'
} as const

export type CalendarScalarFieldEnum = (typeof CalendarScalarFieldEnum)[keyof typeof CalendarScalarFieldEnum]


export const ChainMethodLockScalarFieldEnum = {
  id: 'id',
  isLocked: 'isLocked',
  expiresAt: 'expiresAt',
  updatedAt: 'updatedAt'
} as const

export type ChainMethodLockScalarFieldEnum = (typeof ChainMethodLockScalarFieldEnum)[keyof typeof ChainMethodLockScalarFieldEnum]


export const CronExecutionLogScalarFieldEnum = {
  id: 'id',
  batchId: 'batchId',
  batchName: 'batchName',
  startedAt: 'startedAt',
  completedAt: 'completedAt',
  duration: 'duration',
  status: 'status',
  errorMessage: 'errorMessage',
  result: 'result',
  createdAt: 'createdAt'
} as const

export type CronExecutionLogScalarFieldEnum = (typeof CronExecutionLogScalarFieldEnum)[keyof typeof CronExecutionLogScalarFieldEnum]


export const RentaStoreScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  active: 'active',
  sortOrder: 'sortOrder',
  name: 'name',
  code: 'code',
  updatedAt: 'updatedAt'
} as const

export type RentaStoreScalarFieldEnum = (typeof RentaStoreScalarFieldEnum)[keyof typeof RentaStoreScalarFieldEnum]


export const RentaDealScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  active: 'active',
  sortOrder: 'sortOrder',
  detalType: 'detalType',
  orderedAt: 'orderedAt',
  contractNum: 'contractNum',
  previousContractId: 'previousContractId',
  contractHasChanged: 'contractHasChanged',
  maintanance: 'maintanance',
  toyota: 'toyota',
  carType: 'carType',
  mat: 'mat',
  invitationFee: 'invitationFee',
  moneyCollectionScheduledAt: 'moneyCollectionScheduledAt',
  moneyCollectedAt: 'moneyCollectedAt',
  willRegisterdAt: 'willRegisterdAt',
  dlOrder: 'dlOrder',
  orderPaperSubmittedAt: 'orderPaperSubmittedAt',
  contractPaperSubmittedAt: 'contractPaperSubmittedAt',
  registerPaperSubmittedAt: 'registerPaperSubmittedAt',
  storeNote: 'storeNote',
  error: 'error',
  orderPaperReturnedAt: 'orderPaperReturnedAt',
  contractPaperReturnedAt: 'contractPaperReturnedAt',
  registeredAt: 'registeredAt',
  scannedAt: 'scannedAt',
  storeNote2: 'storeNote2',
  contractPrice: 'contractPrice',
  ProfitPrice: 'ProfitPrice',
  userId: 'userId',
  tentativeRegisteredAt: 'tentativeRegisteredAt',
  rentaCustomerId: 'rentaCustomerId',
  updatedAt: 'updatedAt'
} as const

export type RentaDealScalarFieldEnum = (typeof RentaDealScalarFieldEnum)[keyof typeof RentaDealScalarFieldEnum]


export const RentaDailyReportScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  active: 'active',
  sortOrder: 'sortOrder',
  Memo: 'Memo',
  date: 'date',
  time: 'time',
  visitType: 'visitType',
  increasedNegotiationsCount: 'increasedNegotiationsCount',
  remarks: 'remarks',
  userId: 'userId',
  rentaStoreId: 'rentaStoreId',
  rentaCustomerId: 'rentaCustomerId',
  introductionAchieved: 'introductionAchieved',
  approachType: 'approachType',
  updatedAt: 'updatedAt',
  useHoujinDb: 'useHoujinDb'
} as const

export type RentaDailyReportScalarFieldEnum = (typeof RentaDailyReportScalarFieldEnum)[keyof typeof RentaDailyReportScalarFieldEnum]


export const RentaCustomerScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  name: 'name',
  code: 'code',
  userId: 'userId',
  carCount: 'carCount',
  type: 'type',
  address1: 'address1',
  address2: 'address2',
  fax: 'fax',
  industryCode: 'industryCode',
  industryCodeName: 'industryCodeName',
  kana: 'kana',
  nameBottom: 'nameBottom',
  nameTop: 'nameTop',
  phone: 'phone',
  postalCode: 'postalCode',
  rentaStoreId: 'rentaStoreId',
  repKana: 'repKana',
  repName: 'repName',
  repPos: 'repPos',
  leaseCompanyName: 'leaseCompanyName',
  result: 'result',
  maintenanceDestination: 'maintenanceDestination',
  remarks: 'remarks',
  pic: 'pic',
  rentaReferenceId: 'rentaReferenceId',
  updatedAt: 'updatedAt',
  mergeCandidatesIds: 'mergeCandidatesIds'
} as const

export type RentaCustomerScalarFieldEnum = (typeof RentaCustomerScalarFieldEnum)[keyof typeof RentaCustomerScalarFieldEnum]


export const RentaReferenceScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  date: 'date',
  remarks: 'remarks',
  rentaCustomerId: 'rentaCustomerId',
  refFromId: 'refFromId',
  refToId: 'refToId',
  updatedAt: 'updatedAt'
} as const

export type RentaReferenceScalarFieldEnum = (typeof RentaReferenceScalarFieldEnum)[keyof typeof RentaReferenceScalarFieldEnum]


export const RefFromScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  rentaCustomerId: 'rentaCustomerId',
  updatedAt: 'updatedAt'
} as const

export type RefFromScalarFieldEnum = (typeof RefFromScalarFieldEnum)[keyof typeof RefFromScalarFieldEnum]


export const RefToScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  rentaCustomerId: 'rentaCustomerId',
  updatedAt: 'updatedAt'
} as const

export type RefToScalarFieldEnum = (typeof RefToScalarFieldEnum)[keyof typeof RefToScalarFieldEnum]


export const PurposeScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  rentaDailyReportId: 'rentaDailyReportId',
  purposeMasterId: 'purposeMasterId',
  date: 'date',
  userId: 'userId',
  updatedAt: 'updatedAt'
} as const

export type PurposeScalarFieldEnum = (typeof PurposeScalarFieldEnum)[keyof typeof PurposeScalarFieldEnum]


export const PurposeMasterScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  name: 'name',
  type: 'type',
  color: 'color',
  userId: 'userId',
  aggregateAs: 'aggregateAs',
  updatedAt: 'updatedAt'
} as const

export type PurposeMasterScalarFieldEnum = (typeof PurposeMasterScalarFieldEnum)[keyof typeof PurposeMasterScalarFieldEnum]


export const OutcomeScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  rentaDailyReportId: 'rentaDailyReportId',
  outcomeMasterId: 'outcomeMasterId',
  date: 'date',
  userId: 'userId',
  updatedAt: 'updatedAt'
} as const

export type OutcomeScalarFieldEnum = (typeof OutcomeScalarFieldEnum)[keyof typeof OutcomeScalarFieldEnum]


export const OutcomeMasterScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  name: 'name',
  type: 'type',
  color: 'color',
  userId: 'userId',
  aggregateAs: 'aggregateAs',
  updatedAt: 'updatedAt'
} as const

export type OutcomeMasterScalarFieldEnum = (typeof OutcomeMasterScalarFieldEnum)[keyof typeof OutcomeMasterScalarFieldEnum]


export const AlternateInfoScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  carName: 'carName',
  dueDate: 'dueDate',
  type: 'type',
  rentaDailyReportId: 'rentaDailyReportId',
  rentaCustomerId: 'rentaCustomerId',
  isRead: 'isRead',
  isRead2: 'isRead2',
  updatedAt: 'updatedAt'
} as const

export type AlternateInfoScalarFieldEnum = (typeof AlternateInfoScalarFieldEnum)[keyof typeof AlternateInfoScalarFieldEnum]


export const InsuranceInfoScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  insuranceCompany: 'insuranceCompany',
  dueDate: 'dueDate',
  imageUrl: 'imageUrl',
  rentaDailyReportId: 'rentaDailyReportId',
  rentaCustomerId: 'rentaCustomerId',
  isRead: 'isRead',
  isRead2: 'isRead2',
  updatedAt: 'updatedAt'
} as const

export type InsuranceInfoScalarFieldEnum = (typeof InsuranceInfoScalarFieldEnum)[keyof typeof InsuranceInfoScalarFieldEnum]


export const ExtraInfoScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  sortOrder: 'sortOrder',
  date: 'date',
  remarks: 'remarks',
  imageUrl: 'imageUrl',
  rentaDailyReportId: 'rentaDailyReportId',
  rentaCustomerId: 'rentaCustomerId',
  isRead: 'isRead',
  isRead2: 'isRead2',
  updatedAt: 'updatedAt'
} as const

export type ExtraInfoScalarFieldEnum = (typeof ExtraInfoScalarFieldEnum)[keyof typeof ExtraInfoScalarFieldEnum]


export const UcarScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  qrIssuedAt: 'qrIssuedAt',
  processLastUpdatedAt: 'processLastUpdatedAt',
  active: 'active',
  sortOrder: 'sortOrder',
  sateiDataConfirmedAt: 'sateiDataConfirmedAt',
  dataSource: 'dataSource',
  sateiID: 'sateiID',
  number98: 'number98',
  NO_SIRETYUM: 'NO_SIRETYUM',
  DD_SIIRE: 'DD_SIIRE',
  arrivedAt: 'arrivedAt',
  meihenBi: 'meihenBi',
  masshoBi: 'masshoBi',
  secondMeihenbi: 'secondMeihenbi',
  destination: 'destination',
  inkanCertificateExpiredAt: 'inkanCertificateExpiredAt',
  inspectionExpiredAt: 'inspectionExpiredAt',
  plate: 'plate',
  processedAs: 'processedAs',
  purchaseType: 'purchaseType',
  remarks: 'remarks',
  runnable: 'runnable',
  storeToPickUp: 'storeToPickUp',
  shitadoriKbn: 'shitadoriKbn',
  kounyuShaOrderNumber: 'kounyuShaOrderNumber',
  souhsinJikoku: 'souhsinJikoku',
  henkinRequired: 'henkinRequired',
  accountingRecievedAt: 'accountingRecievedAt',
  paybackScheduledAt: 'paybackScheduledAt',
  upperCarregisteredAt: 'upperCarregisteredAt',
  registerDate: 'registerDate',
  registerdAt: 'registerdAt',
  annualTax: 'annualTax',
  earlyYear: 'earlyYear',
  earlyMonth: 'earlyMonth',
  storeNumber: 'storeNumber',
  accountType: 'accountType',
  accountNumber: 'accountNumber',
  accountNameKana: 'accountNameKana',
  paymentNoticeRecievedAt: 'paymentNoticeRecievedAt',
  isPayed: 'isPayed',
  petCount: 'petCount',
  petPrice: 'petPrice',
  prefCount: 'prefCount',
  prefPrice: 'prefPrice',
  taxCustomerName: 'taxCustomerName',
  taxJobNote: 'taxJobNote',
  destinationStoreId: 'destinationStoreId',
  daihatsuReserve: 'daihatsuReserve',
  exception: 'exception',
  inkanAlternate: 'inkanAlternate',
  inspectionAlternate: 'inspectionAlternate',
  paymentNoticeRecieved: 'paymentNoticeRecieved',
  remarksHq: 'remarksHq',
  tmpPlate: 'tmpPlate',
  tmpChassisNumber: 'tmpChassisNumber',
  tmpColor: 'tmpColor',
  tmpModelYear: 'tmpModelYear',
  tmpBrandName: 'tmpBrandName',
  tmpModelName: 'tmpModelName',
  tmpGrade: 'tmpGrade',
  tmpType: 'tmpType',
  tmpCommonType: 'tmpCommonType',
  tmpFrameNumber: 'tmpFrameNumber',
  tmpTransmissionType: 'tmpTransmissionType',
  tmpRegistrationClassNumber: 'tmpRegistrationClassNumber',
  tmpRegistrationKana: 'tmpRegistrationKana',
  tmpLandAffairsName: 'tmpLandAffairsName',
  modified_brandName: 'modified_brandName',
  modified_modelName: 'modified_modelName',
  modified_frameNumber: 'modified_frameNumber',
  modified_chassisNumber: 'modified_chassisNumber',
  modified_type: 'modified_type',
  modified_grade: 'modified_grade',
  modified_modelYear: 'modified_modelYear',
  modified_length: 'modified_length',
  modified_width: 'modified_width',
  modified_height: 'modified_height',
  ucarLastProcessMasterId: 'ucarLastProcessMasterId',
  bankMasterId: 'bankMasterId',
  yuchoShitenNo: 'yuchoShitenNo',
  bankBranchMasterId: 'bankBranchMasterId',
  userId: 'userId',
  storeId: 'storeId',
  tmpRentalStoreId: 'tmpRentalStoreId',
  newCarId: 'newCarId'
} as const

export type UcarScalarFieldEnum = (typeof UcarScalarFieldEnum)[keyof typeof UcarScalarFieldEnum]


export const Number98IssueHistoryScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  active: 'active',
  sortOrder: 'sortOrder',
  number: 'number'
} as const

export type Number98IssueHistoryScalarFieldEnum = (typeof Number98IssueHistoryScalarFieldEnum)[keyof typeof Number98IssueHistoryScalarFieldEnum]


export const AppliedUcarGarageSlotScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  active: 'active',
  sortOrder: 'sortOrder',
  appliedAt: 'appliedAt',
  finishedAt: 'finishedAt',
  ucarGarageSlotMasterId: 'ucarGarageSlotMasterId',
  sateiID: 'sateiID'
} as const

export type AppliedUcarGarageSlotScalarFieldEnum = (typeof AppliedUcarGarageSlotScalarFieldEnum)[keyof typeof AppliedUcarGarageSlotScalarFieldEnum]


export const UcarGarageSlotMasterScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  active: 'active',
  sortOrder: 'sortOrder',
  garageNumber: 'garageNumber',
  color: 'color',
  ucarGarageLocationMasterId: 'ucarGarageLocationMasterId'
} as const

export type UcarGarageSlotMasterScalarFieldEnum = (typeof UcarGarageSlotMasterScalarFieldEnum)[keyof typeof UcarGarageSlotMasterScalarFieldEnum]


export const UcarGarageLocationMasterScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  active: 'active',
  sortOrder: 'sortOrder',
  name: 'name',
  color: 'color'
} as const

export type UcarGarageLocationMasterScalarFieldEnum = (typeof UcarGarageLocationMasterScalarFieldEnum)[keyof typeof UcarGarageLocationMasterScalarFieldEnum]


export const BankMasterScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  active: 'active',
  sortOrder: 'sortOrder',
  code: 'code',
  name: 'name',
  color: 'color'
} as const

export type BankMasterScalarFieldEnum = (typeof BankMasterScalarFieldEnum)[keyof typeof BankMasterScalarFieldEnum]


export const BankBranchMasterScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  active: 'active',
  sortOrder: 'sortOrder',
  code: 'code',
  name: 'name',
  branchNameShort: 'branchNameShort',
  branchKana: 'branchKana',
  searchKana: 'searchKana',
  color: 'color',
  bankCode: 'bankCode'
} as const

export type BankBranchMasterScalarFieldEnum = (typeof BankBranchMasterScalarFieldEnum)[keyof typeof BankBranchMasterScalarFieldEnum]


export const UcarProcessScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  processCode: 'processCode',
  dataSource: 'dataSource',
  date: 'date',
  sortOrder: 'sortOrder',
  sateiID: 'sateiID',
  remarks: 'remarks',
  userId: 'userId'
} as const

export type UcarProcessScalarFieldEnum = (typeof UcarProcessScalarFieldEnum)[keyof typeof UcarProcessScalarFieldEnum]


export const UcarPaperWorkNotesScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  active: 'active',
  sortOrder: 'sortOrder',
  userId: 'userId',
  ucarId: 'ucarId',
  type: 'type',
  content: 'content',
  resolvedAt: 'resolvedAt',
  updatedAt: 'updatedAt'
} as const

export type UcarPaperWorkNotesScalarFieldEnum = (typeof UcarPaperWorkNotesScalarFieldEnum)[keyof typeof UcarPaperWorkNotesScalarFieldEnum]


export const UcarRequestScalarFieldEnum = {
  id: 'id',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
  active: 'active',
  sortOrder: 'sortOrder',
  sateiID: 'sateiID',
  requestType: 'requestType',
  reason: 'reason',
  status: 'status',
  approvedAt: 'approvedAt',
  approvedById: 'approvedById',
  rejectedReason: 'rejectedReason',
  userId: 'userId',
  ucarId: 'ucarId'
} as const

export type UcarRequestScalarFieldEnum = (typeof UcarRequestScalarFieldEnum)[keyof typeof UcarRequestScalarFieldEnum]


export const SortOrder = {
  asc: 'asc',
  desc: 'desc'
} as const

export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export const QueryMode = {
  default: 'default',
  insensitive: 'insensitive'
} as const

export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


export const NullsOrder = {
  first: 'first',
  last: 'last'
} as const

export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]



/**
 * Field references
 */


/**
 * Reference to a field of type 'Int'
 */
export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


/**
 * Reference to a field of type 'Int[]'
 */
export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


/**
 * Reference to a field of type 'DateTime'
 */
export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


/**
 * Reference to a field of type 'DateTime[]'
 */
export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


/**
 * Reference to a field of type 'Boolean'
 */
export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


/**
 * Reference to a field of type 'Float'
 */
export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


/**
 * Reference to a field of type 'Float[]'
 */
export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


/**
 * Reference to a field of type 'String'
 */
export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


/**
 * Reference to a field of type 'String[]'
 */
export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    

/**
 * Batch Payload for updateMany & deleteMany & createMany
 */
export type BatchPayload = {
  count: number
}

export const defineExtension = runtime.Extensions.defineExtension as unknown as runtime.Types.Extensions.ExtendsHook<"define", TypeMapCb, runtime.Types.Extensions.DefaultArgs>
export type DefaultPrismaClient = PrismaClient
export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
export type PrismaClientOptions = ({
  /**
   * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-pg`.
   */
  adapter: runtime.SqlDriverAdapterFactory
  accelerateUrl?: never
} | {
  /**
   * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
   */
  accelerateUrl: string
  adapter?: never
}) & {
  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat
  /**
   * @example
   * ```
   * // Shorthand for `emit: 'stdout'`
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events only
   * log: [
   *   { emit: 'event', level: 'query' },
   *   { emit: 'event', level: 'info' },
   *   { emit: 'event', level: 'warn' }
   *   { emit: 'event', level: 'error' }
   * ]
   * 
   * / Emit as events and log to stdout
   * og: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * 
   * ```
   * Read more in our [docs](https://pris.ly/d/logging).
   */
  log?: (LogLevel | LogDefinition)[]
  /**
   * The default values for transactionOptions
   * maxWait ?= 2000
   * timeout ?= 5000
   */
  transactionOptions?: {
    maxWait?: number
    timeout?: number
    isolationLevel?: TransactionIsolationLevel
  }
  /**
   * Global configuration for omitting model fields by default.
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   omit: {
   *     user: {
   *       password: true
   *     }
   *   }
   * })
   * ```
   */
  omit?: GlobalOmitConfig
  /**
   * SQL commenter plugins that add metadata to SQL queries as comments.
   * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
   * 
   * @example
   * ```
   * const prisma = new PrismaClient({
   *   adapter,
   *   comments: [
   *     traceContext(),
   *     queryInsights(),
   *   ],
   * })
   * ```
   */
  comments?: runtime.SqlCommenterPlugin[]
}
export type GlobalOmitConfig = {
  car?: Prisma.CarOmit
  userProcessConfirmation?: Prisma.UserProcessConfirmationOmit
  notes?: Prisma.NotesOmit
  damageNameMaster?: Prisma.DamageNameMasterOmit
  noteNameMaster?: Prisma.NoteNameMasterOmit
  bpSummary?: Prisma.BpSummaryOmit
  processNameMaster?: Prisma.ProcessNameMasterOmit
  process?: Prisma.ProcessOmit
  releaseNotes?: Prisma.ReleaseNotesOmit
  crUser?: Prisma.CrUserOmit
  juchuShitadoriDb?: Prisma.JuchuShitadoriDbOmit
  oldCars_Base?: Prisma.OldCars_BaseOmit
  number98?: Prisma.Number98Omit
  zAIKO_Base?: Prisma.ZAIKO_BaseOmit
  upassFamilyTree?: Prisma.UpassFamilyTreeOmit
  uPASS?: Prisma.UPASSOmit
  qR_Prosess?: Prisma.QR_ProsessOmit
  deliverSchedule?: Prisma.DeliverScheduleOmit
  area?: Prisma.AreaOmit
  loadingVehicle?: Prisma.LoadingVehicleOmit
  slot?: Prisma.SlotOmit
  newCar?: Prisma.NewCarOmit
  orderSwitchingHisotory?: Prisma.OrderSwitchingHisotoryOmit
  desiredTorokuDate?: Prisma.DesiredTorokuDateOmit
  newCarLeadTime?: Prisma.NewCarLeadTimeOmit
  crInspectionHistory?: Prisma.CrInspectionHistoryOmit
  seisanYoteiHistory?: Prisma.SeisanYoteiHistoryOmit
  userProgressAggregationTable?: Prisma.UserProgressAggregationTableOmit
  progressAggregationTable?: Prisma.ProgressAggregationTableOmit
  progressAggregationTableRecord?: Prisma.ProgressAggregationTableRecordOmit
  furiateStatusOnApprovement?: Prisma.FuriateStatusOnApprovementOmit
  carTransferHistory?: Prisma.CarTransferHistoryOmit
  tenpoTsuikoShinseiHeader?: Prisma.TenpoTsuikoShinseiHeaderOmit
  tenpoTsuikoShinseiDetail?: Prisma.TenpoTsuikoShinseiDetailOmit
  tenpoTsuikoData?: Prisma.TenpoTsuikoDataOmit
  store?: Prisma.StoreOmit
  user?: Prisma.UserOmit
  googleAccessToken?: Prisma.GoogleAccessTokenOmit
  roleMaster?: Prisma.RoleMasterOmit
  userRole?: Prisma.UserRoleOmit
  calendar?: Prisma.CalendarOmit
  chainMethodLock?: Prisma.ChainMethodLockOmit
  cronExecutionLog?: Prisma.CronExecutionLogOmit
  rentaStore?: Prisma.RentaStoreOmit
  rentaDeal?: Prisma.RentaDealOmit
  rentaDailyReport?: Prisma.RentaDailyReportOmit
  rentaCustomer?: Prisma.RentaCustomerOmit
  rentaReference?: Prisma.RentaReferenceOmit
  refFrom?: Prisma.RefFromOmit
  refTo?: Prisma.RefToOmit
  purpose?: Prisma.PurposeOmit
  purposeMaster?: Prisma.PurposeMasterOmit
  outcome?: Prisma.OutcomeOmit
  outcomeMaster?: Prisma.OutcomeMasterOmit
  alternateInfo?: Prisma.AlternateInfoOmit
  insuranceInfo?: Prisma.InsuranceInfoOmit
  extraInfo?: Prisma.ExtraInfoOmit
  ucar?: Prisma.UcarOmit
  number98IssueHistory?: Prisma.Number98IssueHistoryOmit
  appliedUcarGarageSlot?: Prisma.AppliedUcarGarageSlotOmit
  ucarGarageSlotMaster?: Prisma.UcarGarageSlotMasterOmit
  ucarGarageLocationMaster?: Prisma.UcarGarageLocationMasterOmit
  bankMaster?: Prisma.BankMasterOmit
  bankBranchMaster?: Prisma.BankBranchMasterOmit
  ucarProcess?: Prisma.UcarProcessOmit
  ucarPaperWorkNotes?: Prisma.UcarPaperWorkNotesOmit
  ucarRequest?: Prisma.UcarRequestOmit
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

export type GetLogType<T> = CheckIsLogLevel<
  T extends LogDefinition ? T['level'] : T
>;

export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
  ? GetLogType<T[number]>
  : never;

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findUnique'
  | 'findUniqueOrThrow'
  | 'findMany'
  | 'findFirst'
  | 'findFirstOrThrow'
  | 'create'
  | 'createMany'
  | 'createManyAndReturn'
  | 'update'
  | 'updateMany'
  | 'updateManyAndReturn'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'
  | 'count'
  | 'runCommandRaw'
  | 'findRaw'
  | 'groupBy'

/**
 * `PrismaClient` proxy available in interactive transactions.
 */
export type TransactionClient = Omit<DefaultPrismaClient, runtime.ITXClientDenyList>

